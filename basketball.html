<!DOCTYPE HTML>
<!--
	Solid State by HTML5 UP
	html5up.net | @ajlkn
	Free for personal and commercial use under the CCA 3.0 license (html5up.net/license)
-->
<html>
	<head>
		<title>HORSE (Basketball Party Game)</title>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
		<link rel="stylesheet" href="assets/css/main.css" />
		<noscript><link rel="stylesheet" href="assets/css/noscript.css" /></noscript>
	</head>
	<body class="is-preload">

		<!-- Page Wrapper -->
			<div id="page-wrapper">

				<!-- Header -->
					<header id="header">
						<h1><a href="index.html">Lewis Hill</a></h1>
						<nav>
							<a href="#menu">Menu</a>
						</nav>
					</header>

				<!-- Menu -->
					<nav id="menu">
						<div class="inner">
							<h2>Menu</h2>
							<ul class="links">
								<li><a href="index.html">Home</a></li>
								<li><a href="basketball.html">HORSE (Basketball Party Game)</a></li>
								<li><a href="inventory.html">Inventory System</a></li>
								<li><a href="roguelike.html">Procedural Roguelike</a></li>
								<li><a href="gamejam.html">Climax Game Jam</a></li>
							</ul>
							<a href="#" class="close">Close</a>
						</div>
					</nav>

				<!-- Wrapper -->
					<section id="wrapper">
						<header id="Top">
							<div class="inner">
								<h2 class="align-center">HORSE (Basketball Party Game) (UE5 C++)</h2>
								<p class="align-center">HORSE is a Basketball Party Game inspired from the popular playground game of the same name. The majority of the game was made using C++ in UE5, with anything UI related being executed using Blueprints.</p>
								<ul class="actions special">
									<li>
										<a href="#Movement" class="button primary">Grabbing and Throwing</a>
									</li>
									<li>
										<a href="#Procedural" class="button primary">Predicting Ball Trajectory</a>
									</li>
									<li>
										<a href="#Reincarnation" class="button primary">Manipulating the Ball</a>
									</li>
									<li>
										<a href="#Enemies" class="button primary">"Local Multiplayer"</a>
									</li>
								</ul>

								<ul class="actions special">
								<li>
								<a href="https://lewis-hill.itch.io/horse" target="_blank" class="button">Link to Itch.io</a>
								</li>
								</ul>
							</div>
						</header>

						<!-- Movement -->
						<div class="wrapper style3">
							<header id="Movement">
								<br>
								<div class="inner">
									<h2><u>Grabbing and Throwing</u></h2>
								</div>
							</header>
							<div class="inner">
								<video class="image left" controls src="images/Basketball/grabbing.mp4"></video>			
								<h3 class="major">Ball Control</h3>
								<p>By adding a PhysicsHandle Component on the Player and creating a cusotm "Grabber" class, I was able to add the functionality of picking up and throwing the ball. The Grabber checks against a custom trace channel to see if any valid objects are within grabbing distance. The PhysicsHandle deals with grabbing the object. In Tick, the location of the grabbed object is updated.</p>
								<p>When the ball is thrown, it is released from the PhysicsHandle and an impulse is added to it. By holding down the Throw button before releasing, more power is added to the impulse. I added a shake to the ball using a Vector Timeline to add small offsets to the ball while the throw is charging up.</p>
								<p>The springy feel of the ball while it's grabbed is achieved by altering some of the values found on the PhysicsHandle.</p>

								<ul class="actions">
									<li>
									<button class="button">See Grabber Code</button>
									<div class="codecontent">
											
<pre>bool UGrabber::GetGrabbableInReach(FHitResult& OutHitResult) const
	{
		FVector Start = GetComponentLocation();
		FVector End = Start + GetForwardVector() * MaxGrabDistance;
		DrawDebugLine(GetWorld(), Start, End, FColor::Orange);
	
		FCollisionShape Sphere = FCollisionShape::MakeSphere(GrabRadius);
		return GetWorld()->SweepSingleByChannel(
			OutHitResult,
			Start, End,
			FQuat::Identity,
			ECC_GameTraceChannel2,
			Sphere
		);
	}
	
	void UGrabber::Grab()
	{
		//Only attempt to grab if we have a physics component, or if the turn is still on-going
		if (GetPhysicsHandleComponent() == nullptr || GameMode->IsTurnOver)
		{
			return;
		}
	
		//Test to see if any grabbable objects are within range
		FHitResult HitResult;
		bool HasHit = GetGrabbableInReach(HitResult);
	
		if (HasHit && GameMode)
		{
			//Reset projectile spawn points ready to use again
			if (Spawner)
			{
				Spawner->SetVisibility(true, 0, Spawner->SpawnedObjects.Num());
				Spawner->ResetLocation();
			}
	
			UPrimitiveComponent* HitComponent = HitResult.GetComponent();
			AActor* HitActor = HitResult.GetActor();
	
			if (Cast<ABasketball>(HitActor))
			{
				if (GameMode->IsPlacingPhase)
				{
					return;
				}
	
				GameMode->SetGrabbedBallUI(true, true);
				PlayerCharacter->IsHoldingBall = true;
			}
	
			ToyboxObject = Cast<AToyboxObject>(HitActor);
	
			if (ToyboxObject)
			{
				ToyboxObject->SecondMesh->AttachToComponent(ToyboxObject->Mesh, FAttachmentTransformRules::KeepWorldTransform);
				
				if (!GetMatchingToyboxObject(HitComponent))
				{
					return;
				}
			}
	
			FRotator TargetRotation = FRotator(ToyBoxRotationX, GetComponentRotation().Yaw, ToyBoxRotationZ);
	
			//If we've grabbed a toybox spawner, spawn a toybox object and grab that object
			if (AToyboxSpawner* ToyboxSpawner = Cast<AToyboxSpawner>(HitActor))
			{
				if (GameMode->ToyboxObjectsLeftToSpawn == 0)
				{
					return;
				}
	
				//Make sure the toybox spawner outline is deactivated 
				if (CurrentOutlinedComponent)
				{
					CurrentOutlinedComponent->SetRenderCustomDepth(false);
					CurrentOutlinedComponent = nullptr;
					GameMode->GrabbableObjectInView(false);
				}
	
				ToyboxObject = ToyboxSpawner->SpawnToyboxObject();
	
				if (ToyboxObject)
				{
					//Stop spinning toybox objects spinning while holding
					if (ToyboxObject->ShouldSpin)
					{
						ToyboxObject->IsSpinning = false;
					}
	
					ToyBoxObjectMesh = ToyboxObject->Mesh;
	
					SetGrabbedComponent(ToyBoxObjectMesh, HitResult.GetActor()->GetActorLocation(), TargetRotation);
	
					if (GameMode)
					{
						GameMode->PlacedToyboxObjects.Add(ToyboxObject);
						GameMode->ToyboxObjectsLeftToSpawn--;
						GameMode->UpdatePlacingPhaseText(ToyboxObject, true);
					}
	
					//Save the profile of the toybox object and set all channels to overlap
					ChangeToyboxMeshCollision(true);
				}
					
				return;
			}
	
			SetGrabbedComponent(HitComponent, HitResult.GetActor()->GetActorLocation(), TargetRotation);
	
			if (Cast<ABasketball>(GrabbedComponent->GetOwner()))
			{
				GetOwner()->Tags.Add("HoldingBall");
			}
	
			//Turn off object outline if there are any activated
			if (CurrentOutlinedComponent)
			{
				CurrentOutlinedComponent->SetRenderCustomDepth(false);
				CurrentOutlinedComponent = nullptr;
				GameMode->GrabbableObjectInView(false);
			}
	
			if (ToyboxObject)
			{
				//Stop spinning toybox objects spinning while holding
				if (ToyboxObject->ShouldSpin)
				{
					ToyboxObject->IsSpinning = false;
				}
	
				ToyBoxObjectMesh = ToyboxObject->Mesh;
				ChangeToyboxMeshCollision(true);
	
				if (GameMode)
				{
					GameMode->UpdatePlacingPhaseText(ToyboxObject, true);
				}
			}
			else
			{
				ToyBoxObjectMesh = nullptr;
				ToyboxObject = nullptr;
			}
		}
	}
	
	void UGrabber::Release()
	{
		//If an object is being grabbed
		if (GetPhysicsHandleComponent() && GrabbedComponent)
		{	
			if (Cast<ABasketball>(GrabbedComponent->GetOwner()))
			{
				GameMode->SetGrabbedBallUI(false, true);
				PlayerCharacter->IsHoldingBall = false;
			}
	
			//If the grabbed object is a ToyBox object
			if (GrabbedComponent->GetOwner()->ActorHasTag("Toybox") && ToyBoxObjectMesh)
			{
				if (ToyboxObject->CurrentOverlappingActors > 0)
				{
					return;
				}
	
				//Let spinning objects spin again on release
				if (ToyboxObject->ShouldSpin)
				{
					ToyboxObject->IsSpinning = true;
				}
	
				if (GameMode)
				{
					GameMode->UpdatePlacingPhaseText(ToyboxObject, false);
				}
	
				ChangeToyboxMeshCollision(false);
			}
	
			if (Cast<ABasketball>(GrabbedComponent->GetOwner()))
			{
				GetOwner()->Tags.Remove("HoldingBall");
			}
	
			HoldDistance = 50.f;
			GrabbedComponent->WakeAllRigidBodies();
			GrabbedComponent->GetOwner()->Tags.Remove("Grabbed");
			GrabbedComponent = nullptr;
			GetPhysicsHandleComponent()->ReleaseComponent();
	
			if (ToyboxObject)
			{
				ToyboxObject->SecondMesh->DetachFromComponent(FDetachmentTransformRules::KeepWorldTransform);
			}
	
			if (Spawner)
			{
				Spawner->SetVisibility(false, 0, Spawner->SpawnedObjects.Num());
			}
		}
	}
	
	void UGrabber::Throw(bool IsRandomThrow)
	{
		if (GrabbedComponent == nullptr)
		{
			return;
		}
	
		if (GameMode)
		{
			GameMode->ThrowLocation = GetOwner()->GetActorLocation();
		}
	
		if (IsRandomThrow)
		{
			GrabbedComponent->
				AddImpulse(FVector(GetForwardVector().X + FMath::RandRange(-1.f, 1.f),
					GetForwardVector().Y + FMath::RandRange(-1.f, 1.f),
					GetForwardVector().Z + FMath::RandRange(-1.f, 1.f))
					* CurrentThrowPower, NAME_None, false);
		}
		else
		{
			GrabbedComponent->SetPhysicsLinearVelocity(FVector(0, 0, 0));
			GrabbedComponent->AddImpulse(GetForwardVector() * CurrentThrowPower, NAME_None, false);
		}
	
		FVector Velocity = GetForwardVector() * CurrentThrowPower;
	
		if (PlayerCharacter->GetCharacterMovement()->IsFalling())
		{
			if (PlayerActionsLeft > 0)
			{
				GameMode->ActionPerformed(PlayerActionName);
				PlayerActionsLeft--;
			}
		}
	
		Release();
	}
	
	void UGrabber::SetGrabbedComponent(UPrimitiveComponent* ComponentToSet, FVector Location, FRotator Rotation)
	{
		if (ToyboxObject)
		{
			ComponentToSet->SetSimulatePhysics(true);
		}
	
		UE_LOG(LogTemp, Display, TEXT("%s : turned on physics sim"), *ComponentToSet->GetName());
		ComponentToSet->WakeAllRigidBodies();
		ComponentToSet->GetOwner()->Tags.Add("Grabbed");
	
		GetPhysicsHandleComponent()->GrabComponentAtLocationWithRotation(
			ComponentToSet,
			NAME_None,
			Location,
			Rotation
		);
	
		GrabbedComponent = GetPhysicsHandleComponent()->GetGrabbedComponent();
	}</pre>
									</div>
									</li>
									</ul>

								<ul class="actions">
									<li><a href="#Top" class="button primary">Jump to top</a></li>
								</ul>
								
							</div>
						</div>

						<!-- Procedural generation -->
						<div class="wrapper alt style">
							<header id="Procedural">
								<br>
								<div class="inner">
									<h2><u>Predicting Ball Trajectory</u></h2>
								</div>
							</header>
							<div class="inner">
								<video class="image left" controls src="images/Basketball/projectilepath.mp4"></video>

								<h3 class="major">Setting up the Preview Path</h3>
								<p>Unreal Engine has a built in function called PredictProjectilePath. It takes in a velocity and location, aswell as other Parameters such as whether it should consider collisions with a certain trace channel, to create a path of debug spheres of where the ball will go.</p>
								<p>Executing this function only creates one path, so to allow for multiple bounces, I call the function again and decrement the "MaxBounces" int variable so I can restrict the amount of times it is called. This time I plug in the mirrored velocity of the ball at the point of impact, aswell as the impact location.</p>
								<p>The Preview Path also works with the bounce pad and cannon objects I have in the game. If the path collides with a bounce pad for example, it will show the bounce path the ball will make. For a cannon, the path will shoot out of where the cannon faces, so everything is reasonably accurate.</p>

								<h3 class="major">Procedural level layout</h3>
								<p>The "Generation Point" object starts at 0,0 and an rectangle icon is created for the start room. The Point then translates randomly in one of 4 directions, creates an icon, and repeats until the specified number of icons have been created. This is to prepare for creating the room outlines, and these icons are also used to visualise the mini-map. If the Point happens to overlap an existing room, it chooses a direction and translates in that direction until an empty space is found.</p>
								<p>To create the room outlines, for every room, an overlap circle checks in each direction to see which rooms are surrounding it, and chooses from the list of pre-made room outlines to perfectly connect each room with exits.</p>
								<p>The room centers are then created from a list of easy and hard room centers, which are placed so that the levels are harder closer towards the end of the level. The start and end room centers are pre-determined. These steps ensure that there is a high chance that no two rooms will be the same, and that the layout of rooms will be unique to every run.</p>

								<ul class="actions">
									<li>
									<button class="button">See Level Generation Code</button>
									<div class="codecontent">
<pre>public class LevelGenerator : MonoBehaviour
{
	public GameObject layoutRoom;
	public Color startColour, endColour;

	public int distanceToEnd;

	public Transform generatorPoint;

	public enum Direction { up, right, down, left};
	public Direction selectedDirection;

	public float xOffset = 18f, yOffset = 10f;

	public LayerMask whatisRoom;

	private GameObject endRoom;

	private List<GameObject> layoutRoomObjects = new List<GameObject>();

	public List<RoomPrefab> roomPrefabs = new List<RoomPrefab>();

	public RoomCenter centerStart, centerEnd;
	public RoomCenter[] potentialCentersEasy;
	public RoomCenter[] potentialCentersHard;

	private List<GameObject> generatedOutlines = new List<GameObject>();

	// Start is called before the first frame update
	void Start()
	{   //Create start room
		Instantiate(layoutRoom, generatorPoint.position, generatorPoint.rotation).GetComponent<SpriteRenderer>().color = startColour;

		selectedDirection = (Direction)Random.Range(0, 4);
		MoveGenerationPoint();

		//Create a room, choose where the next room will be and repeat
		for (int i = 0; i < distanceToEnd; i++)
		{
			GameObject newRoom = Instantiate(layoutRoom, generatorPoint.position, generatorPoint.rotation);

			layoutRoomObjects.Add(newRoom);

			if (i + 1 == distanceToEnd)
			{
				newRoom.GetComponent<SpriteRenderer>().color = endColour;
				layoutRoomObjects.RemoveAt(layoutRoomObjects.Count - 1);
				endRoom = newRoom;
			}
			selectedDirection = (Direction)Random.Range(0, 4);
			MoveGenerationPoint();

			while (Physics2D.OverlapCircle(generatorPoint.position, .2f, whatisRoom))
			{
				MoveGenerationPoint();
			}
		}

		//create room outlines
		CreateRoomOutline(Vector3.zero, 0);
		foreach(GameObject room in layoutRoomObjects)
		{
			int position = layoutRoomObjects.IndexOf(room);
			CreateRoomOutline(room.transform.position, position);
		}
		CreateRoomOutline(endRoom.transform.position, distanceToEnd - 1);

		//Create the room centers that will go inside the room outlines
		foreach(GameObject outline in generatedOutlines)
		{
			bool generateCenter = true;

			//Create specific start room center
			if (outline.transform.position == Vector3.zero)
			{
				Instantiate(centerStart, outline.transform.position, transform.rotation).theRoom = outline.GetComponent<Room>();
				generateCenter = false;
			}
			//Create specific end room center
			if (outline.transform.position == endRoom.transform.position)
			{
				Instantiate(centerEnd, outline.transform.position, transform.rotation).theRoom = outline.GetComponent<Room>();
				generateCenter = false;
			}
			//Decide difficulty of room center based on how far to the end of the level it is
			if (generateCenter)
			{
				if (outline.GetComponent<Room>().roomNumber / distanceToEnd <= 0.25f)
				{
					int centerSelect = Random.Range(0, potentialCentersEasy.Length);

					Instantiate(potentialCentersEasy[centerSelect], outline.transform.position, transform.rotation).theRoom = outline.GetComponent<Room>();
				}
				else
				{
					int centerSelect = Random.Range(0, potentialCentersHard.Length);

					Instantiate(potentialCentersHard[centerSelect], outline.transform.position, transform.rotation).theRoom = outline.GetComponent<Room>();
				}
				
			}
		}
	}

	// Update is called once per frame
	void Update()
	{
#if UNITY_EDITOR
		if (Input.GetKey(KeyCode.R))
		{
			Scene scene = SceneManager.GetActiveScene(); SceneManager.LoadScene(scene.name);
		}

#endif
	}

	//Choose where the rooms will spawn
	public void MoveGenerationPoint()
	{
		switch (selectedDirection)
		{
			case Direction.up:
				generatorPoint.position += new Vector3(0f, yOffset, 0f);
				break;

			case Direction.right:
				generatorPoint.position += new Vector3(xOffset, 0f, 0f);
				break;

			case Direction.down:
				generatorPoint.position += new Vector3(0f, -yOffset, 0f);
				break;

			case Direction.left:
				generatorPoint.position += new Vector3(-xOffset, 0f, 0f);
				break;
		}
	}

	//Decide which Room outline will spawn so the rooms connect
	private RoomPrefab PickRoom(bool exitUp, bool exitRight, bool exitDown, bool exitLeft)
	{
		foreach (RoomPrefab rp in roomPrefabs)
		{
			if (rp.exitUp == exitUp && rp.exitRight == exitRight && rp.exitDown == exitDown && rp.exitLeft == exitLeft)
			{
				return rp;
			}
		}
		return null;
	}

	//Create the room outline
	public void CreateRoomOutline(Vector3 position, int roomNumber)
	{
		bool exitUp = Physics2D.OverlapCircle(position + new Vector3(0, yOffset), .2f, whatisRoom);
		bool exitDown = Physics2D.OverlapCircle(position + new Vector3(0, -yOffset), .2f, whatisRoom);
		bool exitRight = Physics2D.OverlapCircle(position + new Vector3(xOffset, 0), .2f, whatisRoom);
		bool exitLeft = Physics2D.OverlapCircle(position + new Vector3(-xOffset, 0), .2f, whatisRoom);

		var roomPrefab = PickRoom(exitUp, exitRight, exitDown, exitLeft);
		if (roomPrefab != null)
		{
			var room = Instantiate(roomPrefab.prefab, position, Quaternion.identity, transform);
			room.GetComponent<Room>().roomNumber = roomNumber;
			generatedOutlines.Add(room);
		}
	}
}

[System.Serializable]
public class RoomPrefab
{
	public bool exitUp;
	public bool exitRight;
	public bool exitDown;
	public bool exitLeft;
	public GameObject prefab;
} </pre>
									</div>
									</li>
									</ul>

								<ul class="actions">
									<li><a href="#Top" class="button primary">Jump to top</a></li>
								</ul>
							</div>
						</div>

						<!-- NPC and Chests -->
						<div class="wrapper style3">
							<header id="Reincarnation">
								<br>
								<div class="inner">
									<h2><u>Reincarnation mechanic and card elements</u></h2>
								</div>
							</header>
							<div class="inner">

								<video class="image left" controls src="images/Roguelike/Videos/Reincarnate.mp4"></video>

								<h3 class="major">Reincarnation
								</h3>
								<p>The reincarnation mechanic is what the game is mostly revolves around: when the Player's health becomes 0, instead of a game over, you reincarnate and become stronger. In contrast, when the Player is fully healed they get weaker and can lead to a game over. This means the Player has to find ways of damaging themselves while the enemies attempt to heal them.</p>
								<p>There are multiple objects the Player can find in the rooms to damage themselves, such as triggering arrows to fire from a statue, to coaxing enemies to fire at uneven structures and causing debris to fall from the ceiling.</p>

								<h3 class="major">Getting stronger with cards
								</h3>
								<p>Upon reincarnating, the Player picks between 3 cards which give the Player benefits, such as higher damage output or increased firerate. Better card rarities offer bonuses to these stats. Being fully healed by enemies causes the last aquired card to be destroyed. Being fully healed with no cards causes a game over.</p>
								<p>The Card Manager takes care of the list of cards aqcuired and cards that appear for the Player to pick from. This includes the Inventory, where you can hover over cards aqcuired to see their stats. The script for the Card itself deals with the information it holds, such as the stats, rarity and ability.</p>

								<ul class="actions">
									<li>
									<button class="button">See Reincarnation Card Code</button>
									<div class="codecontent">
<pre>public class ReincarnationCard : MonoBehaviour
{
	public Animator anim;

	public bool isLeft, isRight, isChosen, isCurseCard;

	public RectTransform rectTransform;

	public Text goodEffectText, badEffectText, titleText, cursedText, cursedTextTwo;

	public int damageAmount, healthAmount, healthOnReincarnateAmount, damageTakenIncrease, healAmount, cardRarity;
	public float fireRateIncrease;

	public Sprite[] cardRarities, cardRaritiesHighlighted;
	public Sprite cardRarityHighlighted;
	public GameObject audioManager;

	public enum cardType { damageGivenUpHealthUp, healthDownDamageGivenDown, damageTakenIncreaseHealthUp, fireRateUpDamageDown};
	public enum curseCardType { takeExtraHeal};
	public cardType selectedType;
	public curseCardType selectedCurse;

	// Start is called before the first frame update
	void Start()
	{
		audioManager = GameObject.Find("Audio Manager");

		if (!isCurseCard)
		{
			cursedText.gameObject.SetActive(false);
			cursedTextTwo.gameObject.SetActive(false);
			cardRarity = Random.Range(0, 4);
		}
		else
		{
			goodEffectText.gameObject.SetActive(false);
			badEffectText.gameObject.SetActive(false);
			cardRarity = 4;
		}

		cardRarityHighlighted = cardRaritiesHighlighted[cardRarity];

		gameObject.GetComponent<Image>().sprite = cardRarities[cardRarity];

		if (!isCurseCard)
		{
			selectedType = (cardType)Random.Range(0, 4);
		}
		else
		{
			selectedCurse = (curseCardType)(0);
		}

		//Set the card rarity
		if (cardRarity == 0)
		{
			titleText.text = "Common";
		}
		if (cardRarity == 1)
		{
			titleText.text = "Rare";
		}
		if (cardRarity == 2)
		{
			titleText.text = "Epic";
		}
		if (cardRarity == 3)
		{
			titleText.text = "Legendary";
		}
		if (cardRarity == 4)
		{
			titleText.text = "Curse";
		}

		//Set the functionality and text for the various card effects
		switch (selectedType)
		{
			case cardType.damageGivenUpHealthUp:
				damageAmount = Random.Range(6, 9) + cardRarity;
				healthAmount = Random.Range(6, 9) - cardRarity;
				goodEffectText.text = "+" + damageAmount + " damage";
				badEffectText.text = "+" + healthAmount + " max health";
				break;

			case cardType.healthDownDamageGivenDown:
				damageAmount = Random.Range(8, 11) - cardRarity;
				healthOnReincarnateAmount = Random.Range(8, 11) + cardRarity;
				goodEffectText.text = "-" + healthOnReincarnateAmount + " health after reincarnate";
				badEffectText.text = "-" + damageAmount + " damage";
				break;

			case cardType.damageTakenIncreaseHealthUp:
				damageTakenIncrease = Random.Range(9, 12) + cardRarity;
				healthAmount = Random.Range(7, 10) - cardRarity;
				goodEffectText.text = "+" + damageTakenIncrease + " damage taken from objects";
				badEffectText.text = "+" + healthAmount + " max health";
				break;

			case cardType.fireRateUpDamageDown:
				fireRateIncrease = Random.Range(4, 5) * 0.1f + (cardRarity * 0.1f);
				damageAmount = Random.Range(7, 10) - cardRarity;
				goodEffectText.text = "+" + fireRateIncrease + " shots per second";
				badEffectText.text = "-" + damageAmount + " damage";
				break;
		}

		switch (selectedCurse)
		{
			case curseCardType.takeExtraHeal:
				healAmount = 4;
				cursedText.text = "+" + healAmount + " heal given by enemies";
				cursedTextTwo.text = "Curse cards cannot be removed";
				break;
		}
	}

	// Update is called once per frame
	void Update()
	{
		if (UIController.instance.isReincarnationCardClicked && !isChosen)
		{
			anim.SetBool("isDiscarded", true);
		}
	}

	public void Hoverable()
	{
		anim.SetBool("isHoverable", true);
	}

	public void OnMouseHover()
	{
		if (anim.GetBool("isHoverable"))
		{
			anim.SetBool("isMouseHover", true);
			//audioManager.GetComponent<AudioManager>().PlaySFX(2);
		}
	}

	public void OffMouseHover()
	{
		if (anim.GetBool("isMouseHover"))
		{
			anim.SetBool("isMouseHover", false);
		}
	}

	//When the Player chooses a card, apply the effects 
	public void OnMouseClick()
	{
		if (anim.GetBool("isClickable") && anim != null)
		{
			audioManager.GetComponent<AudioManager>().PlaySFX(3);
			UIController.instance.isReincarnationCardClicked = true;
			isChosen = true;
			anim.SetBool("isMouseClick", true);
			anim.SetBool("isHoverable", false);

			switch (selectedType)
			{
				case cardType.damageGivenUpHealthUp:
					PlayerController.instance.IncreaseMaxHealth(healthAmount);
					Gun.instance.IncreaseDamageToGive(damageAmount);
					break;

				case cardType.healthDownDamageGivenDown:
					PlayerController.instance.DecreaseHealthOnReincarnation(healthOnReincarnateAmount);
					Gun.instance.IncreaseDamageToGive(-damageAmount);
					PlayerController.instance.IncreaseMaxHealth(0);
					break;

				case cardType.damageTakenIncreaseHealthUp:
					PlayerController.instance.IncreaseDamageTaken(damageTakenIncrease);
					PlayerController.instance.IncreaseMaxHealth(healthAmount);
					break;

				case cardType.fireRateUpDamageDown:
					Gun.instance.IncreaseFireRate(fireRateIncrease);
					Gun.instance.IncreaseDamageToGive(-damageAmount);
					PlayerController.instance.IncreaseMaxHealth(0);
					break;
			}

			switch (selectedCurse)
			{
				case curseCardType.takeExtraHeal:
					PlayerController.instance.IncreaseHealToTake(healAmount);
					PlayerController.instance.IncreaseMaxHealth(0);
					break;
			}

			CardManager.instance.Equip(this);

			anim.SetBool("isClickable", false); 

			Debug.Log("Click!");
		}
	}

	//Reverse the card effects if destroyed
	public void OnRemove()
	{
		audioManager.GetComponent<AudioManager>().LoudenMusic();

		//Remove the stats and set current health to OnReinarncateHealth and Unpause the game
		switch (selectedType)
		{
			case cardType.damageGivenUpHealthUp:
				PlayerController.instance.IncreaseMaxHealth(-healthAmount);
				Gun.instance.IncreaseDamageToGive(-damageAmount);
				break;

			case cardType.healthDownDamageGivenDown:
				PlayerController.instance.DecreaseHealthOnReincarnation(-healthOnReincarnateAmount);
				Gun.instance.IncreaseDamageToGive(damageAmount);
				PlayerController.instance.IncreaseMaxHealth(0);
				break;

			case cardType.damageTakenIncreaseHealthUp:
				PlayerController.instance.IncreaseDamageTaken(-damageTakenIncrease);
				PlayerController.instance.IncreaseMaxHealth(-healthAmount);
				break;

			case cardType.fireRateUpDamageDown:
				Gun.instance.IncreaseFireRate(-fireRateIncrease);
				Gun.instance.IncreaseDamageToGive(damageAmount);
				PlayerController.instance.IncreaseMaxHealth(0);
				break;
		}

		switch (selectedCurse)
		{
			case curseCardType.takeExtraHeal:
				PlayerController.instance.IncreaseHealToTake(-healAmount);
				PlayerController.instance.IncreaseMaxHealth(0);
				break;
		}

		PlayerController.instance.currentHealth = PlayerController.instance.onReincarnateHealth;
		GameManager.instance.UnpauseGame();
		PlayerController.instance.isDeincarnated = false;
		PlayerController.instance.ActivateInvincibility(2f);
	}

	public void PlaySound()
	{
		audioManager.GetComponent<AudioManager>().PlaySFX(2);
	}
}</pre>
									</div>
									</li>
									</ul>

									<ul class="actions">
										<li>
										<button class="button">See Card Manager Code</button>
										<div class="codecontent">
<pre>public class CardManager : MonoBehaviour
{
	public static CardManager instance;

	#region Singleton
	void Awake()
	{
		instance = this;
	}

	#endregion

	public List<ReincarnationCard> currentCards = new List<ReincarnationCard>();

	public List<GameObject> cardIcons = new List<GameObject>();
	public List<GameObject> curseCardIcons = new List<GameObject>();
	private float xOffset = 60f;

	public GameObject cardIconImage;
	public Transform cardIconHolder, curseCardIconHolder;

	[HideInInspector]
	public bool inventoryOpen = false;

	public RectTransform cardIconBackground, cursedCardIconBackground;

	public Image fadeScreen;

	public Text inventoryText;

	public GameObject audioManager;

	public GameObject inventoryTutorial;

	public bool gameOver;

	private void Start()
	{
		instance = this;
		audioManager = GameObject.Find("Audio Manager");
	}

	private void Update()
	{
		if (Input.GetKeyDown(KeyCode.I))
		{
			if (inventoryOpen)
			{
				CloseInventory();
			}
			else if (!GameManager.instance.isPausedMenu && !GameManager.instance.isPausedReincarnate && cardIcons.Count + curseCardIcons.Count > 0)
			{
				OpenInventory();
			}
		}
	}

	//When the Player chooses a card, equip it 
	public void Equip (ReincarnationCard newCard)
	{
		ReincarnationCard createdCard = newCard;

		if (!newCard.isCurseCard)
		{
			currentCards.Add(newCard);
			cardIconBackground.gameObject.SetActive(true);
		}
		else
		{
			cursedCardIconBackground.gameObject.SetActive(true);
			cardIconBackground.gameObject.SetActive(true);
		}

		AddCardIcon(createdCard);
	}

	//Remove the most recently aqcuired card
	public void Unequip()
	{
		if (currentCards.Count > 0)
		{
			audioManager.GetComponent<AudioManager>().QuietenMusic();
			audioManager.GetComponent<AudioManager>().PlaySFX(13);
			audioManager.GetComponent<AudioManager>().StopSFX(19);

			//Start the "Remove" animation for the last card in the list, set the position to be centered and remove from the list
			currentCards[currentCards.Count - 1].anim.SetBool("isRemoved", true);
			currentCards[currentCards.Count - 1].gameObject.transform.SetParent(UIController.instance.reincarnationCardHolder.transform);
			currentCards.RemoveAt(currentCards.Count - 1);

			if (!PlayerController.instance.canMove)
			{
				PlayerController.instance.canMove = true;
			}

			RemoveCardIcon();

			if (cardIcons.Count + curseCardIcons.Count == 0)
			{
				cardIconBackground.gameObject.SetActive(false);
			}
		}
		else
		{
			gameOver = true;
			Debug.Log("Game Over!");
			GameManager.instance.GameOver();
		}
	}

	//Adds the icon to the Inventory
	public void AddCardIcon(ReincarnationCard newCard)
	{
		if (newCard.isCurseCard)
		{
			GameObject card = Instantiate(cardIconImage, Vector3.zero, transform.rotation, curseCardIconHolder.transform);
			card.transform.localPosition = new Vector3(xOffset * (curseCardIcons.Count + 1), 0);
			card.GetComponent<CardIcon>().theCard = newCard;
			card.GetComponent<Image>().sprite = newCard.cardRarities[newCard.cardRarity];
			curseCardIcons.Add(card);
			cursedCardIconBackground.sizeDelta = new Vector3(cursedCardIconBackground.sizeDelta.x + 30f, cardIconBackground.sizeDelta.y);
		}
		else if (!newCard.isCurseCard)
		{
			GameObject card = Instantiate(cardIconImage, Vector3.zero, transform.rotation, cardIconHolder.transform);
			card.transform.localPosition = new Vector3(xOffset * (cardIcons.Count + 1), 0);
			card.GetComponent<CardIcon>().theCard = newCard;
			card.GetComponent<Image>().sprite = newCard.cardRarities[newCard.cardRarity];
			cardIcons.Add(card);
			cardIconBackground.sizeDelta = new Vector3(cardIconBackground.sizeDelta.x + 30f, cardIconBackground.sizeDelta.y);
		}
		
	}

	//Removes the icon from the Inventory
	public void RemoveCardIcon()
	{
		GameObject card = cardIcons[cardIcons.Count - 1];
		cardIcons.RemoveAt(cardIcons.Count - 1);
		Destroy(card.gameObject);
		cardIconBackground.sizeDelta = new Vector3(cardIconBackground.sizeDelta.x - 30f, cardIconBackground.sizeDelta.y);
	}

	public void OpenInventory()
	{
		if (!TutorialManager.instance.isInventoryTutorialFinished)
		{
			inventoryTutorial.gameObject.SetActive(true);
		}

		inventoryOpen = true;
		GameManager.instance.PauseGame();
		fadeScreen.color = new Color(fadeScreen.color.r, fadeScreen.color.g, fadeScreen.color.b, Mathf.MoveTowards(fadeScreen.color.a, 0.64f, UIController.instance.fadeSpeed));
		inventoryText.text = "Close Inventory";
	}

	public void CloseInventory()
	{
		inventoryOpen = false;
		inventoryTutorial.gameObject.SetActive(false);

		foreach (GameObject card in cardIcons)
		{
			card.GetComponent<CardIcon>().OffMouseHover();
		}

		if (curseCardIcons.Count > 0)
		{
			foreach (GameObject card in curseCardIcons)
			{
				card.GetComponent<CardIcon>().OffMouseHover();
			}
		}

		fadeScreen.color = new Color(fadeScreen.color.r, fadeScreen.color.g, fadeScreen.color.b, Mathf.MoveTowards(fadeScreen.color.a, 0f, UIController.instance.fadeSpeed));

		GameManager.instance.UnpauseGame();

		inventoryText.text = "Open Inventory";
	}
}</pre>
										</div>
										</li>
										</ul>

								<ul class="actions">
									<li><a href="#Top" class="button primary">Jump to top</a></li>
								</ul>
							</div>
						</div>

						<!-- Quests -->
						<div class="wrapper alt style">
							<header id="Enemies">
								<br>
								<div class="inner">
									<h2><u>Enemies</u></h2>
								</div>
							</header>
							<div class="inner">
								<video class="image left" controls src="images/Roguelike/Videos/Enemies.mp4"></video>		
								<h3 class="major">Enemy behaviour
								</h3>
								<p>Each Enemy class has a different set of behaviours that vary based on the conditions in gameplay. For example, Hammer enemies will destroy objects that the Player can use to damage themselves. If there are no objects to destroy, they will chase the Player instead and attempt to stun them, allowing other enemies to heal the Player.</p>
								<p>Another example is the Maid enemy, who chases the Player to heal them when they collide. However, if the Player sets off an arrow to fly, the Maid will chase that instead, and dive into it if within close enough range, depriving the Player from potentially reincarnating. This makes surveying the room quickly a necessity, as performing an action in the wrong order can lead to big mistakes.</p>
								<ul class="actions">
									<li>
									<button class="button">See Enemy Controller Code</button>
									<div class="codecontent">
<pre>public class EnemyController : MonoBehaviour
	{
		[Header("Chase Player")]
		public bool shouldChase;
		public float chasePlayerRange;
	
		[Header("Sacrifice")]
		public bool shouldSacrifice;
		public float chaseProjectileRange, diveRange, diveSpeed;
	
		[Header("Shoot Projectiles")]
		public bool shouldShoot;
		private bool shootBreak = false;
		public float shootSpeed, shootRange,  timeBetweenShots, shootLength, shootBreakLength;
		private float shootTimer, shootBreakTimer, shootLengthTimer;
	
		public float moveSpeed, normalSpeed;
	
		[Header("Dismantle traps")]
		public bool shouldDismantle;
		public bool isMovingToDismantle, isDismantling, isSteppingBack;
		public float dismantleLength, dismantleTimer;
		public Animator hammerAnim;
	
		public Rigidbody2D theRB;
	
		private Vector3 moveDirection;
	
		public Animator anim;
	
		private bool isLookingRight;
	
		public bool isDead = false;
	
		public bool isSacrificing = false;
	
		public bool failedDive = false;
	
		public int health, maxHealth;
	
		public SpriteRenderer theSR;
	
		public Sprite arrowKill;
	
		public GameObject bullet, heartWarningEffect;
	
		public RoomCenter room;
	
		public DamageItems target;
	
		public Coroutine dismantleCoroutine, holdPlayerCoroutine;
	
		public int damageToPlayer = -10;
	
		public GameObject audioManager;
	
		public float cameraXPos, cameraTargetXPos, cameraYPos, cameraTargetYPos;
	
	
		// Start is called before the first frame update
		void Start()
		{
			audioManager = GameObject.Find("Audio Manager");
			health = maxHealth;
			shootBreakTimer = shootBreakLength;
	
			cameraXPos = CameraController.instance.transform.position.x;
			cameraTargetXPos = CameraController.instance.target.transform.position.x;
			cameraYPos = CameraController.instance.transform.position.y;
			cameraTargetYPos = CameraController.instance.target.transform.position.y;
		}
	
		// Update is called once per frame
		void Update()
		{
			if (!isDead)
			{
				if (theSR.isVisible)
				{
					if (GameObject.FindObjectOfType<BossController>() != null || cameraXPos == cameraTargetXPos && cameraYPos == cameraTargetYPos)
					{
						if (PlayerController.instance.canMove && !isDismantling)
						{
							moveDirection = Vector3.zero;
						}
	
						//Do something based on distance from another object
						if (shouldChase && !isSacrificing && !failedDive)
						{
							if (Vector3.Distance(PlayerController.instance.transform.position, transform.position) < chasePlayerRange)
							{
								if (shouldDismantle)
								{
									hammerAnim.SetBool("isChasing", true);
								}
	
								moveDirection = PlayerController.instance.transform.position - transform.position;
								moveSpeed = normalSpeed;
							}
							else if (shouldDismantle)
							{
								hammerAnim.SetBool("isChasing", false);
							}
						}
	
						if (shouldSacrifice)
						{
							if (GameObject.FindGameObjectWithTag("DamageProjectile") != null)
							{
								Projectiles arrow = GameObject.FindGameObjectWithTag("DamageProjectile").GetComponent<Projectiles>();
	
								if (Vector3.Distance(arrow.sacrificeTarget.transform.position, transform.position) < chaseProjectileRange)
								{
									isSacrificing = true;
	
									if (Vector3.Distance(arrow.sacrificeTarget.transform.position, transform.position) <= diveRange)
									{
										anim.SetBool("isDiving", true);
										moveSpeed = diveSpeed;
										moveDirection = arrow.sacrificeTarget.transform.position - transform.position;
									}
									else
									{
										moveDirection = arrow.sacrificeTarget.transform.position - transform.position;
										anim.SetBool("isDiving", false);
										moveSpeed = normalSpeed;
									}
								}
							}
							else
							{
								isSacrificing = false;
								anim.SetBool("isDiving", false);
	
								if (anim.GetCurrentAnimatorStateInfo(0).IsName("Enemy_Dive"))
								{
									failedDive = true;
								}
								else
								{
									failedDive = false;
								}
							}
						}
						else
						{
							theRB.velocity = Vector3.zero;
							anim.SetBool("isDiving", false);
							moveSpeed = normalSpeed;
						}
	
						if (shouldShoot)
						{
							if (Vector3.Distance(PlayerController.instance.transform.position, transform.position) <= shootRange)
							{
								if (!shootBreak)
								{
									shootLengthTimer -= Time.deltaTime;
	
									if (shootLengthTimer <= 0)
									{
										shootBreak = true;
										shootBreakTimer = shootBreakLength;
										Instantiate(heartWarningEffect, transform.position, transform.rotation, gameObject.transform);
										audioManager.GetComponent<AudioManager>().PlaySFX(19);
									}
	
									if (shootTimer > 0)
									{
										shootTimer -= Time.deltaTime;
									}
									else if (!shootBreak)
									{
										Instantiate(bullet, transform.position, transform.rotation);
										audioManager.GetComponent<AudioManager>().PlaySFX(17);
	
	
										shootTimer = timeBetweenShots;
									}
								}
								else
								{
									shootBreakTimer -= Time.deltaTime;
	
									if (shootBreakTimer <= 0)
									{
										shootBreak = false;
										shootLengthTimer = shootLength;
									}
								}
							}
						}
	
						if (shouldDismantle)
						{
							if (room == null)
							{
								if (PlayerController.instance.canMove)
								{
									shouldChase = true;
								}
								else
								{
									shouldChase = false;
									hammerAnim.SetBool("isHitting", false);
								}
							}
	
							if (target != null)
							{
								if (target.GetComponent<DamageItems>().isDead)
								{
									int position = room.damageItems.IndexOf(target);
									room.damageItems.RemoveAt(position);
									Destroy(target.gameObject);
									isMovingToDismantle = false;
									isDismantling = false;
	
									if (dismantleCoroutine != null)
									{
										StopCoroutine(dismantleCoroutine);
										hammerAnim.SetBool("isHitting", false);
									}
								}
							}
	
							if (!isMovingToDismantle && !isDismantling && room != null)
							{
								if (room.damageItems.Count > 0)
								{
									foreach (DamageItems damageItem in room.damageItems)
									{
										if (!damageItem.isTargeted)
										{
											target = damageItem;
											target.isTargeted = true;
											isMovingToDismantle = true;
	
											break;
										}
									}
	
									if (!shouldChase && !isSteppingBack)
									{
										moveDirection = Vector3.zero;
									}
	
									if (!isMovingToDismantle)
									{
										if (PlayerController.instance.canMove)
										{
											shouldChase = true;
										}
										else
										{
											shouldChase = false;
											hammerAnim.SetBool("isHitting", false);
										}
									}
								}
								else
								{
									if (PlayerController.instance.canMove)
									{
										shouldChase = true;
									}
									else
									{
										shouldChase = false;
										hammerAnim.SetBool("isHitting", false);
	
										if (!isSteppingBack)
										{
											moveDirection = Vector3.zero;
										}
									}
								}
							}
							else
							{
								if (target != null && !isDismantling)
								{
									moveDirection = target.GetComponent<DamageItems>().target.transform.position - transform.position;
								}
	
								if (!isMovingToDismantle && !isDismantling && !PlayerController.instance.canMove)
								{
									shouldChase = false;
									hammerAnim.SetBool("isHitting", false);
	
									if (!isSteppingBack)
									{
										moveDirection = Vector3.zero;
									}
								}
							}
	
							if (target != null && target.GetComponent<ReactedObjects>() != null)
							{
								if (target.GetComponent<ReactedObjects>().hasShot == true)
								{
									target.GetComponent<DamageItems>().isTargeted = false;
									int position = room.damageItems.IndexOf(target);
									room.damageItems.RemoveAt(position);
									target = null;
									isMovingToDismantle = false;
									isDismantling = false;
	
									Debug.Log("Removed");
	
									if (dismantleCoroutine != null)
									{
										StopCoroutine(dismantleCoroutine);
										hammerAnim.SetBool("isHitting", false);
									}
								}
							}
						}
					}
				}
	
				moveDirection.Normalize();
	
				theRB.velocity = moveDirection * moveSpeed;
	
				if (moveDirection != Vector3.zero)
				{
					anim.SetBool("isMoving", true);
				}
				else
				{
					anim.SetBool("isMoving", false);
				}
	
				if (moveDirection.x > 0)
				{
					transform.localScale = new Vector3(-1f, 1f, 1f);
					isLookingRight = true;
				}
				else if (moveDirection.x == 0 && isLookingRight == true)
				{
					transform.localScale = new Vector3(-1f, 1f, 1f);
				}
				else
				{
					transform.localScale = Vector3.one;
					isLookingRight = false;
				}
			}
			else
			{
				theRB.velocity = Vector3.zero;
	
				if (dismantleCoroutine != null)
				{
					StopCoroutine(dismantleCoroutine);
					hammerAnim.SetBool("isHitting", false);
				}
	
				if (holdPlayerCoroutine != null)
				{
					StopCoroutine(holdPlayerCoroutine);
	
					if (!PlayerController.instance.canMove)
					{
						PlayerController.instance.canMove = true;
					}
				}
			}
		}
	
		public IEnumerator Dismantle(float dismantleLength)
		{
			hammerAnim.SetBool("isHitting", true);
			shouldChase = false;
			moveDirection = Vector3.zero;
			yield return new WaitForSeconds(dismantleLength);
			hammerAnim.SetBool("isHitting", false);
			int position = room.damageItems.IndexOf(target);
			room.damageItems.RemoveAt(position);
	
			if (target.gameObject.GetComponent<Spike>() != null)
			{
				audioManager.GetComponent<AudioManager>().PlaySFX(21);
			}
	
			if (target.gameObject.GetComponent<ReactedObjects>() != null)
			{
				audioManager.GetComponent<AudioManager>().PlaySFX(22);
			}
	
			Destroy(target.gameObject);
			isMovingToDismantle = false;
			isDismantling = false;
		}
		public IEnumerator HoldPlayer()
		{
			audioManager.GetComponent<AudioManager>().PlaySFX(24);
			shouldChase = false;
			hammerAnim.SetBool("isHitting", false);
			isSteppingBack = true;
			PlayerController.instance.canMove = false;
			moveDirection = transform.position - PlayerController.instance.transform.position;
			PlayerController.instance.KnockOut();
			yield return new WaitForSeconds(1);
			moveDirection = Vector3.zero;
			yield return new WaitForSeconds(1);
			PlayerController.instance.canMove = true;
			isSteppingBack = false;
			moveDirection = PlayerController.instance.transform.position - transform.position;
	
		}
	
		private void OnCollisionEnter2D(Collision2D other)
		{
			if (other.gameObject.CompareTag("Player") && !isDead)
			{
				if (shouldDismantle && shouldChase && !isMovingToDismantle && !other.gameObject.GetComponent<PlayerController>().isInvincible)
				{
					//moveDirection = transform.position - PlayerController.instance.transform.position;
					holdPlayerCoroutine = StartCoroutine(HoldPlayer());
				}
				else if (!shouldDismantle)
				{
					PlayerController.instance.TakeDamage(damageToPlayer - PlayerController.instance.extraHealToTake);
					other.gameObject.GetComponent<PlayerController>().DamagedByEnemy(true);
				}
			}     
		}
	
		private void OnTriggerEnter2D(Collider2D other)
		{
			if (other.gameObject.CompareTag("DamageItem") && shouldDismantle)
			{
				if (target != null)
				{
					if (Vector3.Distance(target.transform.position, transform.position) <= 2f)
					{
						isDismantling = true;
						dismantleCoroutine = StartCoroutine(Dismantle(target.dismantleTime));
					}
				}
			}
		}
	
		public void DamageEnemy(int damage)
		{
			health -= damage;
	
			if (health <= 0)
			{
				if (target != null)
				{
					target.GetComponent<DamageItems>().isTargeted = false;
				}
				anim.SetBool("isDead", true);
				isDead = true;
	
				if (shouldDismantle)
				{
					hammerAnim.SetBool("isHitting", false);
					hammerAnim.SetBool("isChasing", false);
				}
	
				StartCoroutine(DestroyEnemy());
			}
		}
	
		IEnumerator DestroyEnemy()
		{
			yield return new WaitForSeconds(1);
			Destroy(gameObject);
		}
	}</pre>
									</div>
									</li>
									</ul>

								<ul class="actions">
									<li><a href="#Top" class="button primary">Jump to top</a></li>
								</ul>
							</div>
						</div>
					</section>

				<!-- Footer -->
					<section class="wrapper style3">
						<div class="inner">
						<ul class="contact">
							<li class="icon solid fa-envelope"><a href="mailto: lewishill81@gmail.com" target="_blank">lewishill81@gmail.com</a></li>
							<li class="icon brands fa-linkedin"><a href="https://www.linkedin.com/in/lewis-hill-200425195/" target="_blank">Linkedin</a></li>
						</ul>
						</div>
					</section>

			</div>

		<!-- Scripts -->
			<script src="assets/js/jquery.min.js"></script>
			<script src="assets/js/jquery.scrollex.min.js"></script>
			<script src="assets/js/browser.min.js"></script>
			<script src="assets/js/breakpoints.min.js"></script>
			<script src="assets/js/util.js"></script>
			<script src="assets/js/main.js"></script>

	</body>
</html>