<!DOCTYPE HTML>
<!--
	Solid State by HTML5 UP
	html5up.net | @ajlkn
	Free for personal and commercial use under the CCA 3.0 license (html5up.net/license)
-->
<html>
	<head>
		<title>Climax Game Jam 2022</title>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
		<link rel="stylesheet" href="assets/css/main.css" />
		<noscript><link rel="stylesheet" href="assets/css/noscript.css" /></noscript>
	</head>
	<body class="is-preload">

		<!-- Page Wrapper -->
			<div id="page-wrapper">

				<!-- Header -->
					<header id="header">
						<h1><a href="index.html">Lewis Hill</a></h1>
						<nav>
							<a href="#menu">Menu</a>
						</nav>
					</header>

				<!-- Menu -->
					<nav id="menu">
						<div class="inner">
							<h2>Menu</h2>
							<ul class="links">
								<li><a href="index.html">Home</a></li>
								<li><a href="inventory.html">Inventory System</a></li>
								<li><a href="roguelike.html">Procedural Roguelike</a></li>
								<li><a href="gamejam.html">Climax Game Jam</a></li>
							</ul>
							<a href="#" class="close">Close</a>
						</div>
					</nav>

				<!-- Wrapper -->
					<section id="wrapper">
						<header id="Top">
							<div class="inner">
								<h2 class="align-center">Climax Game Jam 2022 (Unity C#)</h2>
								<p class="align-center">For the climax studios game jam we created an arcadey first person parkour game in 48 hours. To be clear, I did not create the player movement and grapple hook functionality. My role was creating the checkpoint system, impleneting the UI and audio, and creating an easy system for the designers to create new levels by putting every variable in the inspector.</p>
								<ul class="actions special">
									<li>
										<a href="#Checkpoint" class="button primary">Checkpoint system</a>
									</li>
									<li>
										<a href="#UI" class="button primary">UI integration</a>
									</li>
									<li>
										<a href="#design" class="button primary">Making it easy for designers</a>
									</li>
								</ul>

								<ul class="actions special">
								<li>
								<a href="https://deadomens.itch.io/destructivedinos" target="_blank" class="button">Link to Itch.io</a>
								</li>
								</ul>
							</div>
						</header>

						<!-- Movement -->
						<div class="wrapper style3">
							<header id="Checkpoint">
								<br>
								<div class="inner">
									<h2><u>Checkpoint system</u></h2>
								</div>
							</header>
							<div class="inner">
								<video class="image left" controls src="images/gamejam/Checkpoints.mp4"></video>			
								<h3 class="major">Checkpoints</h3>
								<p>The Checkpoints are the main gameplay element for our game. When the Player runs into a checkpoint, it adds more time to the timer, and counts towards the total checkpoints required to complete the level. If the timer runs out, it results in a game over and the level must be attempted again. </p>
								<p>The Checkpoint Controller script, attached to the object of the same name, contains all the checkpoint related variables, such as the list of active checkpoints and how many should be active at once. The Change Checkpoints function is called when the Player collides with a checkpoint, and puts that checkpoint into a seperate "discarded" list so it can't be used again.</p>
                                <p>The Checkpoint script is attached to each Checkpoint and calls the Change Checkpoint function on the Checkpoint Controller script whenever the Player collides with it.</p>
                                <h3 class="major">Infinite mode</h3>
								<p>Infinite mode does not have a win condition, instead the Player must accumulate checkpoints until time runs out. This is done with a simple checkbox in the inspector. In the Checkpoint Controller script, it cycles checkpoints between the Active and Disacrded list, ensuring that there are always checkpoints available to run into.</p>
								<ul class="actions">
									<li>
									<button class="button">See Checkpoint Controller Code</button>
									<div class="codecontent">
											
	<pre>public class CheckpointController : MonoBehaviour
        {
            public List<Checkpoint> checkpoints = new List<Checkpoint>();
            public List<Checkpoint> discardedCheckpoints = new List<Checkpoint>();
            public int currentCheckpoint;
            public int checkpointsCollected, checkpointsRequired, numberOfCheckpoints, grappleUses;
            public int grapplesUsed;
        
            public float pitchToAdd, maxPitch, startingPitch;
            public float checkpointsLeft;
        
            public bool isInfinite;
        
            public static CheckpointController instance;
        
            public GameObject audioManager;
        
            private void Awake()
            {
                instance = this;
            }
        
            // Start is called before the first frame update
            void Start()
            {
                //If playing on normal mode
                if (!isInfinite)
                {
                    UIController.instance.checkpointText.gameObject.SetActive(true);
                    checkpointsLeft = checkpointsRequired;
                    UIController.instance.checkpointText.text = "Checkpoints remaining: " + checkpointsLeft;
                }
        
                audioManager = GameObject.Find("Audio Manager");
                // Player starts off with a certain amount of grapples
                grapplesUsed = 0;
        
                // If there are checkpoints, set the first one to be active
                if (checkpoints != null)
                {
                    for (int i = 0; i < numberOfCheckpoints; i++)
                    {
                        currentCheckpoint = Random.Range(0, checkpoints.Count - 1);
                        checkpoints[currentCheckpoint].gameObject.SetActive(true);
                        discardedCheckpoints.Add(checkpoints[currentCheckpoint].GetComponent<Checkpoint>());
                        checkpoints.RemoveAt(currentCheckpoint);     
                    }          
                }
            }
        
            // Update is called once per frame
            void Update()
            {
                
            }
        
            //After colliding with a checkpoint
            public void ChangeCheckpoints(Checkpoint checkpoint)
            {
                if (!isInfinite)
                {
                    checkpointsLeft--;
                    UIController.instance.checkpointText.text = "Checkpoints remaining: " + checkpointsLeft;
                }
        
                UIController.instance.timerBreakTimer = UIController.instance.timerBreakLength;
        
                if (startingPitch + (UIController.instance.currentChain * pitchToAdd) > maxPitch)
                {
                    audioManager.GetComponent<AudioManager>().sfx[7].pitch = maxPitch;
                    audioManager.GetComponent<AudioManager>().sfx[8].pitch = maxPitch;
                    audioManager.GetComponent<AudioManager>().sfx[9].pitch = maxPitch;
                }
                else
                {
                    audioManager.GetComponent<AudioManager>().sfx[7].pitch = startingPitch + (UIController.instance.currentChain * pitchToAdd);
                    audioManager.GetComponent<AudioManager>().sfx[8].pitch = startingPitch + (UIController.instance.currentChain * pitchToAdd);
                    audioManager.GetComponent<AudioManager>().sfx[9].pitch = startingPitch + (UIController.instance.currentChain * pitchToAdd);
                }
        
                int checkpointIndex = Random.Range(7, 10);
                audioManager.GetComponent<AudioManager>().PlaySFX(checkpointIndex);
                // Add 1 to amount of checkpoints collected
                // Add more grapple uses
                // Change grapple text
                checkpointsCollected++;
                grapplesUsed = 0;
                UIController.instance.ReloadGrapples();
        
                // Meet the required checkpoints to win and you win!
                if (checkpointsCollected >= checkpointsRequired && !isInfinite && !UIController.instance.hasWon)
                {
                    {
                        audioManager.GetComponent<AudioManager>().PlaySFX(4);
                        UIController.instance.hasWon = true;
                        GameManager.instance.PauseUnPauseGame();
                        UIController.instance.winText.gameObject.SetActive(true);
                    }
                }
                else
                {
                    if (checkpoints.Count > 0)
                    {
                        //Choose another checkpoint
                        currentCheckpoint = Random.Range(0, checkpoints.Count - 1);
                        checkpoints[currentCheckpoint].gameObject.SetActive(true);
        
                        //Add checkpoint to the discard list and remove checkpoint from the active list
                        discardedCheckpoints.Add(checkpoints[currentCheckpoint].GetComponent<Checkpoint>());
                        checkpoints.RemoveAt(currentCheckpoint);
                    }
                    else if (isInfinite == true)
                    {
                        checkpointsCollected++;
                        discardedCheckpoints.Remove(checkpoint);
        
                        foreach (Checkpoint c in discardedCheckpoints)
                        {
                            if (!c.gameObject.activeInHierarchy)
                            {
                                checkpoints.Add(c);
                            }
                        }  
        
                        foreach (Checkpoint c in checkpoints)
                        {
                            discardedCheckpoints.Remove(c);
                        }
        
                        currentCheckpoint = Random.Range(0, checkpoints.Count - 1);
                        checkpoints[currentCheckpoint].gameObject.SetActive(true);
                        discardedCheckpoints.Add(checkpoints[currentCheckpoint].GetComponent<Checkpoint>());
                        checkpoints.RemoveAt(currentCheckpoint);
        
                        checkpoints.Add(checkpoint);
                    }
                }
            }
        }</pre>
									</div>
									</li>
									</ul>

                                    <ul class="actions">
                                        <li>
                                        <button class="button">See Checkpoint Code</button>
                                        <div class="codecontent">
                                                
        <pre>public class Checkpoint : MonoBehaviour
            {
                public float timeToAdd;
                public GameObject audioManager;
            
                // Start is called before the first frame update
                void Start()
                {
                    // Make sure this gameobject is setactive(false) in the inspector
            
                    audioManager = GameObject.Find("Audio Manager");
                }
            
                // Update is called once per frame
                void Update()
                {
                    
                }
            
                private void OnTriggerEnter(Collider other)
                {
                    // If the Player walks into this, add time to the timer
                    if (other.CompareTag("Player"))
                    {
                        UIController.instance.AddTime(timeToAdd);
                        UIController.instance.AddChain();
                        CheckpointController.instance.ChangeCheckpoints(this);
                        gameObject.SetActive(false);
                        UIController.instance.chainTextAnim.SetTrigger("bounce");
                    }
                }
            }</pre>
                                        </div>
                                        </li>
                                        </ul>

								<ul class="actions">
									<li><a href="#Top" class="button primary">Jump to top</a></li>
								</ul>
								
							</div>
						</div>

						<!-- Procedural generation -->
						<div class="wrapper alt style">
							<header id="UI">
								<br>
								<div class="inner">
									<h2><u>UI and Audio Integration</u></h2>
								</div>
							</header>
							<div class="inner">
								<video class="image left" controls src="images/Roguelike/Videos/Level generation.mp4"></video>

								<h3 class="major">Different rooms every time</h3>
								<p>The rooms are made up out of 2 pre-made parts, the outline and the center. The outline contains the exits, and is generated to connect each room together, while the center contains the enemies, objects and floor tiles.</p>
								<p>There are lists for varieties of both: the outlines list containing every combination of exits possible, and the centers lists containing pre-placed elements to make for purposeful gameplay encounters. The centers lists are split up into easy and hard levels. Building the varieties of outlines and centers was easy as I created a tileset.</p>

								<ul class="actions">
									<li>
									<button class="button">See UI Controller Code</button>
									<div class="codecontent">
<pre>public class LevelGenerator : MonoBehaviour
{
	public GameObject layoutRoom;
	public Color startColour, endColour;

	public int distanceToEnd;

	public Transform generatorPoint;

	public enum Direction { up, right, down, left};
	public Direction selectedDirection;

	public float xOffset = 18f, yOffset = 10f;

	public LayerMask whatisRoom;

	private GameObject endRoom;

	private List<GameObject> layoutRoomObjects = new List<GameObject>();

	public List<RoomPrefab> roomPrefabs = new List<RoomPrefab>();

	public RoomCenter centerStart, centerEnd;
	public RoomCenter[] potentialCentersEasy;
	public RoomCenter[] potentialCentersHard;

	private List<GameObject> generatedOutlines = new List<GameObject>();

	// Start is called before the first frame update
	void Start()
	{   //Create start room
		Instantiate(layoutRoom, generatorPoint.position, generatorPoint.rotation).GetComponent<SpriteRenderer>().color = startColour;

		selectedDirection = (Direction)Random.Range(0, 4);
		MoveGenerationPoint();

		//Create a room, choose where the next room will be and repeat
		for (int i = 0; i < distanceToEnd; i++)
		{
			GameObject newRoom = Instantiate(layoutRoom, generatorPoint.position, generatorPoint.rotation);

			layoutRoomObjects.Add(newRoom);

			if (i + 1 == distanceToEnd)
			{
				newRoom.GetComponent<SpriteRenderer>().color = endColour;
				layoutRoomObjects.RemoveAt(layoutRoomObjects.Count - 1);
				endRoom = newRoom;
			}
			selectedDirection = (Direction)Random.Range(0, 4);
			MoveGenerationPoint();

			while (Physics2D.OverlapCircle(generatorPoint.position, .2f, whatisRoom))
			{
				MoveGenerationPoint();
			}
		}

		//create room outlines
		CreateRoomOutline(Vector3.zero, 0);
		foreach(GameObject room in layoutRoomObjects)
		{
			int position = layoutRoomObjects.IndexOf(room);
			CreateRoomOutline(room.transform.position, position);
		}
		CreateRoomOutline(endRoom.transform.position, distanceToEnd - 1);

		//Create the room centers that will go inside the room outlines
		foreach(GameObject outline in generatedOutlines)
		{
			bool generateCenter = true;

			//Create specific start room center
			if (outline.transform.position == Vector3.zero)
			{
				Instantiate(centerStart, outline.transform.position, transform.rotation).theRoom = outline.GetComponent<Room>();
				generateCenter = false;
			}
			//Create specific end room center
			if (outline.transform.position == endRoom.transform.position)
			{
				Instantiate(centerEnd, outline.transform.position, transform.rotation).theRoom = outline.GetComponent<Room>();
				generateCenter = false;
			}
			//Decide difficulty of room center based on how far to the end of the level it is
			if (generateCenter)
			{
				if (outline.GetComponent<Room>().roomNumber / distanceToEnd <= 0.25f)
				{
					int centerSelect = Random.Range(0, potentialCentersEasy.Length);

					Instantiate(potentialCentersEasy[centerSelect], outline.transform.position, transform.rotation).theRoom = outline.GetComponent<Room>();
				}
				else
				{
					int centerSelect = Random.Range(0, potentialCentersHard.Length);

					Instantiate(potentialCentersHard[centerSelect], outline.transform.position, transform.rotation).theRoom = outline.GetComponent<Room>();
				}
				
			}
		}
	}

	// Update is called once per frame
	void Update()
	{
#if UNITY_EDITOR
		if (Input.GetKey(KeyCode.R))
		{
			Scene scene = SceneManager.GetActiveScene(); SceneManager.LoadScene(scene.name);
		}

#endif
	}

	//Choose where the rooms will spawn
	public void MoveGenerationPoint()
	{
		switch (selectedDirection)
		{
			case Direction.up:
				generatorPoint.position += new Vector3(0f, yOffset, 0f);
				break;

			case Direction.right:
				generatorPoint.position += new Vector3(xOffset, 0f, 0f);
				break;

			case Direction.down:
				generatorPoint.position += new Vector3(0f, -yOffset, 0f);
				break;

			case Direction.left:
				generatorPoint.position += new Vector3(-xOffset, 0f, 0f);
				break;
		}
	}

	//Decide which Room outline will spawn so the rooms connect
	private RoomPrefab PickRoom(bool exitUp, bool exitRight, bool exitDown, bool exitLeft)
	{
		foreach (RoomPrefab rp in roomPrefabs)
		{
			if (rp.exitUp == exitUp && rp.exitRight == exitRight && rp.exitDown == exitDown && rp.exitLeft == exitLeft)
			{
				return rp;
			}
		}
		return null;
	}

	//Create the room outline
	public void CreateRoomOutline(Vector3 position, int roomNumber)
	{
		bool exitUp = Physics2D.OverlapCircle(position + new Vector3(0, yOffset), .2f, whatisRoom);
		bool exitDown = Physics2D.OverlapCircle(position + new Vector3(0, -yOffset), .2f, whatisRoom);
		bool exitRight = Physics2D.OverlapCircle(position + new Vector3(xOffset, 0), .2f, whatisRoom);
		bool exitLeft = Physics2D.OverlapCircle(position + new Vector3(-xOffset, 0), .2f, whatisRoom);

		var roomPrefab = PickRoom(exitUp, exitRight, exitDown, exitLeft);
		if (roomPrefab != null)
		{
			var room = Instantiate(roomPrefab.prefab, position, Quaternion.identity, transform);
			room.GetComponent<Room>().roomNumber = roomNumber;
			generatedOutlines.Add(room);
		}
	}
}

[System.Serializable]
public class RoomPrefab
{
	public bool exitUp;
	public bool exitRight;
	public bool exitDown;
	public bool exitLeft;
	public GameObject prefab;
} </pre>
									</div>
									</li>
									</ul>

                                    <ul class="actions">
                                        <li>
                                        <button class="button">See Game Manager Code</button>
                                        <div class="codecontent">
    <pre>public class LevelGenerator : MonoBehaviour
    {
        public GameObject layoutRoom;
        public Color startColour, endColour;
    
        public int distanceToEnd;
    
        public Transform generatorPoint;
    
        public enum Direction { up, right, down, left};
        public Direction selectedDirection;
    
        public float xOffset = 18f, yOffset = 10f;
    
        public LayerMask whatisRoom;
    
        private GameObject endRoom;
    
        private List<GameObject> layoutRoomObjects = new List<GameObject>();
    
        public List<RoomPrefab> roomPrefabs = new List<RoomPrefab>();
    
        public RoomCenter centerStart, centerEnd;
        public RoomCenter[] potentialCentersEasy;
        public RoomCenter[] potentialCentersHard;
    
        private List<GameObject> generatedOutlines = new List<GameObject>();
    
        // Start is called before the first frame update
        void Start()
        {   //Create start room
            Instantiate(layoutRoom, generatorPoint.position, generatorPoint.rotation).GetComponent<SpriteRenderer>().color = startColour;
    
            selectedDirection = (Direction)Random.Range(0, 4);
            MoveGenerationPoint();
    
            //Create a room, choose where the next room will be and repeat
            for (int i = 0; i < distanceToEnd; i++)
            {
                GameObject newRoom = Instantiate(layoutRoom, generatorPoint.position, generatorPoint.rotation);
    
                layoutRoomObjects.Add(newRoom);
    
                if (i + 1 == distanceToEnd)
                {
                    newRoom.GetComponent<SpriteRenderer>().color = endColour;
                    layoutRoomObjects.RemoveAt(layoutRoomObjects.Count - 1);
                    endRoom = newRoom;
                }
                selectedDirection = (Direction)Random.Range(0, 4);
                MoveGenerationPoint();
    
                while (Physics2D.OverlapCircle(generatorPoint.position, .2f, whatisRoom))
                {
                    MoveGenerationPoint();
                }
            }
    
            //create room outlines
            CreateRoomOutline(Vector3.zero, 0);
            foreach(GameObject room in layoutRoomObjects)
            {
                int position = layoutRoomObjects.IndexOf(room);
                CreateRoomOutline(room.transform.position, position);
            }
            CreateRoomOutline(endRoom.transform.position, distanceToEnd - 1);
    
            //Create the room centers that will go inside the room outlines
            foreach(GameObject outline in generatedOutlines)
            {
                bool generateCenter = true;
    
                //Create specific start room center
                if (outline.transform.position == Vector3.zero)
                {
                    Instantiate(centerStart, outline.transform.position, transform.rotation).theRoom = outline.GetComponent<Room>();
                    generateCenter = false;
                }
                //Create specific end room center
                if (outline.transform.position == endRoom.transform.position)
                {
                    Instantiate(centerEnd, outline.transform.position, transform.rotation).theRoom = outline.GetComponent<Room>();
                    generateCenter = false;
                }
                //Decide difficulty of room center based on how far to the end of the level it is
                if (generateCenter)
                {
                    if (outline.GetComponent<Room>().roomNumber / distanceToEnd <= 0.25f)
                    {
                        int centerSelect = Random.Range(0, potentialCentersEasy.Length);
    
                        Instantiate(potentialCentersEasy[centerSelect], outline.transform.position, transform.rotation).theRoom = outline.GetComponent<Room>();
                    }
                    else
                    {
                        int centerSelect = Random.Range(0, potentialCentersHard.Length);
    
                        Instantiate(potentialCentersHard[centerSelect], outline.transform.position, transform.rotation).theRoom = outline.GetComponent<Room>();
                    }
                    
                }
            }
        }
    
        // Update is called once per frame
        void Update()
        {
    #if UNITY_EDITOR
            if (Input.GetKey(KeyCode.R))
            {
                Scene scene = SceneManager.GetActiveScene(); SceneManager.LoadScene(scene.name);
            }
    
    #endif
        }
    
        //Choose where the rooms will spawn
        public void MoveGenerationPoint()
        {
            switch (selectedDirection)
            {
                case Direction.up:
                    generatorPoint.position += new Vector3(0f, yOffset, 0f);
                    break;
    
                case Direction.right:
                    generatorPoint.position += new Vector3(xOffset, 0f, 0f);
                    break;
    
                case Direction.down:
                    generatorPoint.position += new Vector3(0f, -yOffset, 0f);
                    break;
    
                case Direction.left:
                    generatorPoint.position += new Vector3(-xOffset, 0f, 0f);
                    break;
            }
        }
    
        //Decide which Room outline will spawn so the rooms connect
        private RoomPrefab PickRoom(bool exitUp, bool exitRight, bool exitDown, bool exitLeft)
        {
            foreach (RoomPrefab rp in roomPrefabs)
            {
                if (rp.exitUp == exitUp && rp.exitRight == exitRight && rp.exitDown == exitDown && rp.exitLeft == exitLeft)
                {
                    return rp;
                }
            }
            return null;
        }
    
        //Create the room outline
        public void CreateRoomOutline(Vector3 position, int roomNumber)
        {
            bool exitUp = Physics2D.OverlapCircle(position + new Vector3(0, yOffset), .2f, whatisRoom);
            bool exitDown = Physics2D.OverlapCircle(position + new Vector3(0, -yOffset), .2f, whatisRoom);
            bool exitRight = Physics2D.OverlapCircle(position + new Vector3(xOffset, 0), .2f, whatisRoom);
            bool exitLeft = Physics2D.OverlapCircle(position + new Vector3(-xOffset, 0), .2f, whatisRoom);
    
            var roomPrefab = PickRoom(exitUp, exitRight, exitDown, exitLeft);
            if (roomPrefab != null)
            {
                var room = Instantiate(roomPrefab.prefab, position, Quaternion.identity, transform);
                room.GetComponent<Room>().roomNumber = roomNumber;
                generatedOutlines.Add(room);
            }
        }
    }
    
    [System.Serializable]
    public class RoomPrefab
    {
        public bool exitUp;
        public bool exitRight;
        public bool exitDown;
        public bool exitLeft;
        public GameObject prefab;
    } </pre>
                                        </div>
                                        </li>
                                        </ul>

								<ul class="actions">
									<li><a href="#Top" class="button primary">Jump to top</a></li>
								</ul>
							</div>
						</div>

						<!-- NPC and Chests -->
						<div class="wrapper style3">
							<header id="design">
								<br>
								<div class="inner">
									<h2><u>Code design</u></h2>
								</div>
							</header>
							<div class="inner">

								<video class="image left" controls src="images/Roguelike/Videos/Reincarnate.mp4"></video>

								<h3 class="major">Making it easy for designers
								</h3>
								<p>The reincarnation mechanic is what the game is mostly revolves around: when the Player's health becomes 0, instead of a game over, you reincarnate and become stronger. In contrast, when the Player is fully healed they get weaker and can lead to a game over. This means the Player has to find ways of damaging themselves while the enemies attempt to heal them.</p>
								<p>There are multiple objects the Player can find in the rooms to damage themselves, such as triggering arrows to fire from a statue, to coaxing enemies to fire at uneven structures and causing debris to fall from the ceiling.</p>

								<ul class="actions">
									<li>
									<button class="button">See Checkpoint Controller Code</button>
									<div class="codecontent">
<pre>public class ReincarnationCard : MonoBehaviour
{
	public Animator anim;

	public bool isLeft, isRight, isChosen, isCurseCard;

	public RectTransform rectTransform;

	public Text goodEffectText, badEffectText, titleText, cursedText, cursedTextTwo;

	public int damageAmount, healthAmount, healthOnReincarnateAmount, damageTakenIncrease, healAmount, cardRarity;
	public float fireRateIncrease;

	public Sprite[] cardRarities, cardRaritiesHighlighted;
	public Sprite cardRarityHighlighted;
	public GameObject audioManager;

	public enum cardType { damageGivenUpHealthUp, healthDownDamageGivenDown, damageTakenIncreaseHealthUp, fireRateUpDamageDown};
	public enum curseCardType { takeExtraHeal};
	public cardType selectedType;
	public curseCardType selectedCurse;

	// Start is called before the first frame update
	void Start()
	{
		audioManager = GameObject.Find("Audio Manager");

		if (!isCurseCard)
		{
			cursedText.gameObject.SetActive(false);
			cursedTextTwo.gameObject.SetActive(false);
			cardRarity = Random.Range(0, 4);
		}
		else
		{
			goodEffectText.gameObject.SetActive(false);
			badEffectText.gameObject.SetActive(false);
			cardRarity = 4;
		}

		cardRarityHighlighted = cardRaritiesHighlighted[cardRarity];

		gameObject.GetComponent<Image>().sprite = cardRarities[cardRarity];

		if (!isCurseCard)
		{
			selectedType = (cardType)Random.Range(0, 4);
		}
		else
		{
			selectedCurse = (curseCardType)(0);
		}

		//Set the card rarity
		if (cardRarity == 0)
		{
			titleText.text = "Common";
		}
		if (cardRarity == 1)
		{
			titleText.text = "Rare";
		}
		if (cardRarity == 2)
		{
			titleText.text = "Epic";
		}
		if (cardRarity == 3)
		{
			titleText.text = "Legendary";
		}
		if (cardRarity == 4)
		{
			titleText.text = "Curse";
		}

		//Set the functionality and text for the various card effects
		switch (selectedType)
		{
			case cardType.damageGivenUpHealthUp:
				damageAmount = Random.Range(6, 9) + cardRarity;
				healthAmount = Random.Range(6, 9) - cardRarity;
				goodEffectText.text = "+" + damageAmount + " damage";
				badEffectText.text = "+" + healthAmount + " max health";
				break;

			case cardType.healthDownDamageGivenDown:
				damageAmount = Random.Range(8, 11) - cardRarity;
				healthOnReincarnateAmount = Random.Range(8, 11) + cardRarity;
				goodEffectText.text = "-" + healthOnReincarnateAmount + " health after reincarnate";
				badEffectText.text = "-" + damageAmount + " damage";
				break;

			case cardType.damageTakenIncreaseHealthUp:
				damageTakenIncrease = Random.Range(9, 12) + cardRarity;
				healthAmount = Random.Range(7, 10) - cardRarity;
				goodEffectText.text = "+" + damageTakenIncrease + " damage taken from objects";
				badEffectText.text = "+" + healthAmount + " max health";
				break;

			case cardType.fireRateUpDamageDown:
				fireRateIncrease = Random.Range(4, 5) * 0.1f + (cardRarity * 0.1f);
				damageAmount = Random.Range(7, 10) - cardRarity;
				goodEffectText.text = "+" + fireRateIncrease + " shots per second";
				badEffectText.text = "-" + damageAmount + " damage";
				break;
		}

		switch (selectedCurse)
		{
			case curseCardType.takeExtraHeal:
				healAmount = 4;
				cursedText.text = "+" + healAmount + " heal given by enemies";
				cursedTextTwo.text = "Curse cards cannot be removed";
				break;
		}
	}

	// Update is called once per frame
	void Update()
	{
		if (UIController.instance.isReincarnationCardClicked && !isChosen)
		{
			anim.SetBool("isDiscarded", true);
		}
	}

	public void Hoverable()
	{
		anim.SetBool("isHoverable", true);
	}

	public void OnMouseHover()
	{
		if (anim.GetBool("isHoverable"))
		{
			anim.SetBool("isMouseHover", true);
			//audioManager.GetComponent<AudioManager>().PlaySFX(2);
		}
	}

	public void OffMouseHover()
	{
		if (anim.GetBool("isMouseHover"))
		{
			anim.SetBool("isMouseHover", false);
		}
	}

	//When the Player chooses a card, apply the effects 
	public void OnMouseClick()
	{
		if (anim.GetBool("isClickable") && anim != null)
		{
			audioManager.GetComponent<AudioManager>().PlaySFX(3);
			UIController.instance.isReincarnationCardClicked = true;
			isChosen = true;
			anim.SetBool("isMouseClick", true);
			anim.SetBool("isHoverable", false);

			switch (selectedType)
			{
				case cardType.damageGivenUpHealthUp:
					PlayerController.instance.IncreaseMaxHealth(healthAmount);
					Gun.instance.IncreaseDamageToGive(damageAmount);
					break;

				case cardType.healthDownDamageGivenDown:
					PlayerController.instance.DecreaseHealthOnReincarnation(healthOnReincarnateAmount);
					Gun.instance.IncreaseDamageToGive(-damageAmount);
					PlayerController.instance.IncreaseMaxHealth(0);
					break;

				case cardType.damageTakenIncreaseHealthUp:
					PlayerController.instance.IncreaseDamageTaken(damageTakenIncrease);
					PlayerController.instance.IncreaseMaxHealth(healthAmount);
					break;

				case cardType.fireRateUpDamageDown:
					Gun.instance.IncreaseFireRate(fireRateIncrease);
					Gun.instance.IncreaseDamageToGive(-damageAmount);
					PlayerController.instance.IncreaseMaxHealth(0);
					break;
			}

			switch (selectedCurse)
			{
				case curseCardType.takeExtraHeal:
					PlayerController.instance.IncreaseHealToTake(healAmount);
					PlayerController.instance.IncreaseMaxHealth(0);
					break;
			}

			CardManager.instance.Equip(this);

			anim.SetBool("isClickable", false); 

			Debug.Log("Click!");
		}
	}

	//Reverse the card effects if destroyed
	public void OnRemove()
	{
		audioManager.GetComponent<AudioManager>().LoudenMusic();

		//Remove the stats and set current health to OnReinarncateHealth and Unpause the game
		switch (selectedType)
		{
			case cardType.damageGivenUpHealthUp:
				PlayerController.instance.IncreaseMaxHealth(-healthAmount);
				Gun.instance.IncreaseDamageToGive(-damageAmount);
				break;

			case cardType.healthDownDamageGivenDown:
				PlayerController.instance.DecreaseHealthOnReincarnation(-healthOnReincarnateAmount);
				Gun.instance.IncreaseDamageToGive(damageAmount);
				PlayerController.instance.IncreaseMaxHealth(0);
				break;

			case cardType.damageTakenIncreaseHealthUp:
				PlayerController.instance.IncreaseDamageTaken(-damageTakenIncrease);
				PlayerController.instance.IncreaseMaxHealth(-healthAmount);
				break;

			case cardType.fireRateUpDamageDown:
				Gun.instance.IncreaseFireRate(-fireRateIncrease);
				Gun.instance.IncreaseDamageToGive(damageAmount);
				PlayerController.instance.IncreaseMaxHealth(0);
				break;
		}

		switch (selectedCurse)
		{
			case curseCardType.takeExtraHeal:
				PlayerController.instance.IncreaseHealToTake(-healAmount);
				PlayerController.instance.IncreaseMaxHealth(0);
				break;
		}

		PlayerController.instance.currentHealth = PlayerController.instance.onReincarnateHealth;
		GameManager.instance.UnpauseGame();
		PlayerController.instance.isDeincarnated = false;
		PlayerController.instance.ActivateInvincibility(2f);
	}

	public void PlaySound()
	{
		audioManager.GetComponent<AudioManager>().PlaySFX(2);
	}
}</pre>
									</div>
									</li>
									</ul>

								<ul class="actions">
									<li><a href="#Top" class="button primary">Jump to top</a></li>
								</ul>
							</div>
						</div>
			</div>

		<!-- Scripts -->
			<script src="assets/js/jquery.min.js"></script>
			<script src="assets/js/jquery.scrollex.min.js"></script>
			<script src="assets/js/browser.min.js"></script>
			<script src="assets/js/breakpoints.min.js"></script>
			<script src="assets/js/util.js"></script>
			<script src="assets/js/main.js"></script>

	</body>
</html>