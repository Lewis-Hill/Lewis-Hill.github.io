<!DOCTYPE HTML>
<!--
	Solid State by HTML5 UP
	html5up.net | @ajlkn
	Free for personal and commercial use under the CCA 3.0 license (html5up.net/license)
-->
<html>
	<head>
		<title>Roguelike 2D Game</title>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
		<link rel="stylesheet" href="assets/css/main.css" />
		<noscript><link rel="stylesheet" href="assets/css/noscript.css" /></noscript>
	</head>
	<body class="is-preload">

		<!-- Page Wrapper -->
			<div id="page-wrapper">

				<!-- Header -->
					<header id="header">
						<h1><a href="index.html">Lewis Hill</a></h1>
						<nav>
							<a href="#menu">Menu</a>
						</nav>
					</header>

				<!-- Menu -->
					<nav id="menu">
						<div class="inner">
							<h2>Menu</h2>
							<ul class="links">
								<li><a href="index.html">Home</a></li>
								<li><a href="inventory.html">Inventory System</a></li>
								<li><a href="roguelike.html">Procedural Roguelike</a></li>
								<li><a href="gamejam.html">Climax Game Jam</a></li>
							</ul>
							<a href="#" class="close">Close</a>
						</div>
					</nav>

				<!-- Wrapper -->
					<section id="wrapper">
						<header id="Top">
							<div class="inner">
								<h2 class="align-center">Roguelike 2D Game (Unity C#)</h2>
								<p class="align-center">This game combines the Roguelike genre with card game elements to create a challenging and unique experience. The Reincarnation mechanic makes the Player think in creative ways to get their health to 0. Procedural level generation means you never get the same layout twice. </p>
								<ul class="actions special">
									<li>
										<a href="#Movement" class="button primary">Player Movement</a>
									</li>
									<li>
										<a href="#Procedural" class="button primary">Procedural Generation</a>
									</li>
									<li>
										<a href="#Reincarnation" class="button primary">Reincarnation mechanic</a>
									</li>
									<li>
										<a href="#Enemies" class="button primary">Enemies</a>
									</li>
								</ul>

								<ul class="actions special">
								<li>
								<a href="https://lewis-hill.itch.io/inventory-system-demo" target="_blank" class="button">Link to Itch.io</a>
								</li>
								</ul>
							</div>
						</header>

						<!-- Movement -->
						<div class="wrapper style3">
							<header id="Movement">
								<br>
								<div class="inner">
									<h2><u>Movement</u></h2>
								</div>
							</header>
							<div class="inner">
								<video class="image left" controls src="images/Roguelike/Videos/Movement and camera.mp4"></video>			
								<h3 class="major">Movement</h3>
								<p>After picking up an item using the Interact Interface, the function AddToInventory is called on the Player's Inventory Component. The Data Structure attached to the Item tells the function all the attributes the slot should have. If the Item already exists in the Player's Inventory, it checks to see if the picked up item can be added to an existing slot. If not, a new slot is created for that item.</p>

								<ul class="actions">
									<li>
									<button class="button">See Player Controller Code</button>
									<div class="codecontent">
											
	<pre>class PlayerController : MonoBehaviour
{
	public static PlayerController instance;

	public Rigidbody2D theRb;

	public SpriteRenderer playerSR, bodySR, body2SR;

	public Sprite player, playerHealed, body, bodyHealed, playerDamaged, bodyDamaged;

	public float moveSpeed, activeMoveSpeed;

	public Transform gunHand;

	private Vector2 moveInput;

	public Animator anim;

	public float maxHealth, currentHealth, onReincarnateHealth;
	private float reincarnateHealthToTakeAway = 30f;

	public GameObject rock, firePoint, zEffect;

	public bool isDeincarnated = false;

	public bool canMove = true;

	public float InvincibilityTimer, timeOfInvincibility;

	public bool isInvincible = false;

	public float dashSpeed, dashCooldown, dashInvincibilityTime, dashLength;

	private float damageLength = 0.1f;
	public int extraHealToTake = 0;

	[Header("Card Effects")]
	public bool isDoubleHeal;

	[HideInInspector]
	public int damageTakenIncrease = 0;

	private float dashTimer, dashCooldownTimer, damageTimer;

	public GameObject audioManager;

	private void Awake()
	{
		instance = this;
	}
	// Start is called before the first frame update
	void Start()
	{
		audioManager = GameObject.Find("Audio Manager");
		activeMoveSpeed = moveSpeed;

		//Start the game with the health given after reincarnating
		onReincarnateHealth = maxHealth - reincarnateHealthToTakeAway;
		currentHealth = onReincarnateHealth;
	}

	// Update is called once per frame
	void Update()
	{
		//Handle movement
		if (!GameManager.instance.isPausedReincarnate && !GameManager.instance.isPausedMenu)
		{
			if (damageTimer > 0)
			{
				damageTimer -= Time.deltaTime;
			}
			else
			{
				playerSR.sprite = player;
				bodySR.sprite = body;
				body2SR.sprite = body;
			}

			if (canMove)
			{
				{
					if (isInvincible)
					{
						playerSR.color = new Color(1.0f, 1.0f, 1.0f, 0.5f);
						if (InvincibilityTimer > 0)
						{
							InvincibilityTimer -= Time.deltaTime;
						}
						else
						{
							isInvincible = false;
							playerSR.color = new Color(1.0f, 1.0f, 1.0f, 1.0f);
						}
					}

					moveInput.x = Input.GetAxisRaw("Horizontal");
					moveInput.y = Input.GetAxisRaw("Vertical");

					moveInput.Normalize();

					theRb.velocity = moveInput * activeMoveSpeed;

					Vector3 mousePos = Input.mousePosition;
					Vector3 screenPoint = CameraController.instance.mainCamera.WorldToScreenPoint(transform.localPosition);

					if (mousePos.x < screenPoint.x)
					{
						transform.localScale = new Vector3(-1f, 1f, 1f);
						gunHand.localScale = new Vector3(-1.5f, -1.5f, 1f);
					}
					else
					{
						transform.localScale = new Vector3(1f, 1f, 1f);
						gunHand.localScale = new Vector3(1.5f, 1.5f, 1f);
					}

					Vector2 offset = new Vector2(mousePos.x - screenPoint.x, mousePos.y - screenPoint.y);
					float angle = Mathf.Atan2(offset.y, offset.x) * Mathf.Rad2Deg;

					gunHand.rotation = Quaternion.Euler(0, 0, angle);

					if (moveInput != Vector2.zero)
					{
						anim.SetBool("isMoving", true);
					}
					else
					{
						anim.SetBool("isMoving", false);
					}

					if (Input.GetKeyDown(KeyCode.Space) && dashTimer <= 0 && dashCooldownTimer <= 0)
					{
						audioManager.GetComponent<AudioManager>().PlaySFX(6);
						activeMoveSpeed = dashSpeed;
						ActivateInvincibility(dashInvincibilityTime);
						dashTimer = dashLength;
						anim.SetTrigger("Dash");
					}

					if (dashTimer > 0)
					{
						dashTimer -= Time.deltaTime;
						if (dashTimer <= 0)
						{
							activeMoveSpeed = moveSpeed;
							dashCooldownTimer = dashCooldown;
						}
					}

					if (dashCooldownTimer > 0)
					{
						dashCooldownTimer -= Time.deltaTime;
					}
				}
			}

			else
			{
				theRb.velocity = Vector3.zero;
				anim.SetBool("isMoving", false);
				activeMoveSpeed = moveSpeed;
				dashCooldownTimer = 0;
				dashTimer = 0;

				if (isInvincible)
				{
					isInvincible = false;
					playerSR.color = new Color(1.0f, 1.0f, 1.0f, 1.0f);
					InvincibilityTimer = 0;
				}
			}
		}

		//If player is healed, Deincarnate 
		if (currentHealth >= maxHealth && !isDeincarnated)
		{
			currentHealth = maxHealth;
			isDeincarnated = true;

			GameManager.instance.PauseGame();
			CardManager.instance.Unequip();
			//GameManager.instance.UnpauseGame();
			//ActivateInvincibility(2f);
		}
	}

	//This function covers being damaged by items and healed by enemies
	public void TakeDamage(int damageToTake)
	{
		if (!isInvincible || damageToTake > 0)
		{
			if (damageToTake > currentHealth)
			{
				currentHealth = 0;
			}
			else
			{
				if (isDoubleHeal && damageToTake < 0)
				{
					currentHealth -= damageToTake * 2;
				}
				else
				{
					currentHealth -= damageToTake;
				}
			}
		}
	}

	//One of the card abilities
	public void IncreaseMaxHealth(int healthToIncrease)
	{
		maxHealth += healthToIncrease;
		onReincarnateHealth = maxHealth - reincarnateHealthToTakeAway;
		currentHealth = onReincarnateHealth;
	}

	//This is called when the Player rolls
	public void ActivateInvincibility(float timeOfInvincibility)
	{
		isInvincible = true;
		InvincibilityTimer = timeOfInvincibility;
	}

	//Trigger the visual effect for when the Player is damaged or healed
	public void DamagedByEnemy(bool isEnemy)
	{
		if (isEnemy)
		{
			if (!isInvincible)
			{
				damageTimer = damageLength;
				damageTimer = damageLength;
				playerSR.sprite = playerHealed;
				bodySR.sprite = bodyHealed;
				body2SR.sprite = bodyHealed;
			}
		}

		if (!isEnemy)
		{
			damageTimer = damageLength;
			playerSR.sprite = playerDamaged;
			bodySR.sprite = bodyDamaged;
			body2SR.sprite = bodyDamaged;
		}
	}

	//One of the card abilities
	public void IncreaseDamageTaken(int damageIncrease)
	{
		damageTakenIncrease += damageIncrease;
	}

	//This occurs when a Hammer enemy knocks the Player out
	public void KnockOut()
	{
		Instantiate(zEffect, new Vector3(transform.position.x, transform.position.y + 0.5f), transform.rotation, gameObject.transform);
	}

	//One of the card abilities
	public void DecreaseHealthOnReincarnation(int healthAmount)
	{
		reincarnateHealthToTakeAway += healthAmount;
	}

	//One of the card abilities
	public void IncreaseHealToTake(int heal)
	{
		extraHealToTake += heal;
	}
}</pre>
									</div>
									</li>
									</ul>

								<ul class="actions">
									<li><a href="#Top" class="button primary">Jump to top</a></li>
								</ul>
								
							</div>
						</div>

						<!-- Procedural generation -->
						<div class="wrapper alt style">
							<header id="Procedural">
								<br>
								<div class="inner">
									<h2><u>Procedural Level Generation</u></h2>
								</div>
							</header>
							<div class="inner">
								<video class="image left" controls src="images/Roguelike/Videos/Level generation.mp4"></video>

								<h3 class="major">Different rooms every time</h3>
								<p>The rooms are made up out of 2 pre-made parts, the outline and the center. The outline contains the exits, and is generated to connect each room together, while the center contains the enemies, objects and floor tiles. There are lists for varieties of both, the outlines list containing every combination of exits possible, and the centers lists containing pre-placed elements to make for purposeful gameplay encounters. The centers lists are split up into easy and hard levels.</p>

								<h3 class="major">Procedural level layout</h3>
								<p>The "Generation Point" object starts at 0,0 and an rectangle icon is created for the start room. The Point then translates randomly in one of 4 directions, creates an icon, and repeats until the specified number of icons have been created. This is to prepare for creating the room outlines, and these icons are also used to visualise the mini-map. If the Point happens to overlap an existing room, it chooses a direction and translates in that direction until an empty space is found.</p>
								<p>To create the room outlines, for every room, an overlap circle checks in each direction to see which rooms are surrounding it, and chooses from the list of pre-made room outlines to perfectly connect each room with exits.</p>
								<p>The room centers are then created from a list of easy and hard room centers, which are placed so that the levels are harder closer towards the end of the level. The start and end room centers are pre-determined. These steps ensure that there is a high chance that no two rooms will be the same, and that the layout of rooms will be unique to every run.</p>

								<ul class="actions">
									<li>
									<button class="button">See Level Generation Code</button>
									<div class="codecontent">
<pre>public class LevelGenerator : MonoBehaviour
{
	public GameObject layoutRoom;
	public Color startColour, endColour;

	public int distanceToEnd;

	public Transform generatorPoint;

	public enum Direction { up, right, down, left};
	public Direction selectedDirection;

	public float xOffset = 18f, yOffset = 10f;

	public LayerMask whatisRoom;

	private GameObject endRoom;

	private List<GameObject> layoutRoomObjects = new List<GameObject>();

	public List<RoomPrefab> roomPrefabs = new List<RoomPrefab>();

	public RoomCenter centerStart, centerEnd;
	public RoomCenter[] potentialCentersEasy;
	public RoomCenter[] potentialCentersHard;

	private List<GameObject> generatedOutlines = new List<GameObject>();

	// Start is called before the first frame update
	void Start()
	{   //Create start room
		Instantiate(layoutRoom, generatorPoint.position, generatorPoint.rotation).GetComponent<SpriteRenderer>().color = startColour;

		selectedDirection = (Direction)Random.Range(0, 4);
		MoveGenerationPoint();

		//Create a room, choose where the next room will be and repeat
		for (int i = 0; i < distanceToEnd; i++)
		{
			GameObject newRoom = Instantiate(layoutRoom, generatorPoint.position, generatorPoint.rotation);

			layoutRoomObjects.Add(newRoom);

			if (i + 1 == distanceToEnd)
			{
				newRoom.GetComponent<SpriteRenderer>().color = endColour;
				layoutRoomObjects.RemoveAt(layoutRoomObjects.Count - 1);
				endRoom = newRoom;
			}
			selectedDirection = (Direction)Random.Range(0, 4);
			MoveGenerationPoint();

			while (Physics2D.OverlapCircle(generatorPoint.position, .2f, whatisRoom))
			{
				MoveGenerationPoint();
			}
		}

		//create room outlines
		CreateRoomOutline(Vector3.zero, 0);
		foreach(GameObject room in layoutRoomObjects)
		{
			int position = layoutRoomObjects.IndexOf(room);
			CreateRoomOutline(room.transform.position, position);
		}
		CreateRoomOutline(endRoom.transform.position, distanceToEnd - 1);

		//Create the room centers that will go inside the room outlines
		foreach(GameObject outline in generatedOutlines)
		{
			bool generateCenter = true;

			//Create specific start room center
			if (outline.transform.position == Vector3.zero)
			{
				Instantiate(centerStart, outline.transform.position, transform.rotation).theRoom = outline.GetComponent<Room>();
				generateCenter = false;
			}
			//Create specific end room center
			if (outline.transform.position == endRoom.transform.position)
			{
				Instantiate(centerEnd, outline.transform.position, transform.rotation).theRoom = outline.GetComponent<Room>();
				generateCenter = false;
			}
			//Decide difficulty of room center based on how far to the end of the level it is
			if (generateCenter)
			{
				if (outline.GetComponent<Room>().roomNumber / distanceToEnd <= 0.25f)
				{
					int centerSelect = Random.Range(0, potentialCentersEasy.Length);

					Instantiate(potentialCentersEasy[centerSelect], outline.transform.position, transform.rotation).theRoom = outline.GetComponent<Room>();
				}
				else
				{
					int centerSelect = Random.Range(0, potentialCentersHard.Length);

					Instantiate(potentialCentersHard[centerSelect], outline.transform.position, transform.rotation).theRoom = outline.GetComponent<Room>();
				}
				
			}
		}
	}

	// Update is called once per frame
	void Update()
	{
#if UNITY_EDITOR
		if (Input.GetKey(KeyCode.R))
		{
			Scene scene = SceneManager.GetActiveScene(); SceneManager.LoadScene(scene.name);
		}

#endif
	}

	//Choose where the rooms will spawn
	public void MoveGenerationPoint()
	{
		switch (selectedDirection)
		{
			case Direction.up:
				generatorPoint.position += new Vector3(0f, yOffset, 0f);
				break;

			case Direction.right:
				generatorPoint.position += new Vector3(xOffset, 0f, 0f);
				break;

			case Direction.down:
				generatorPoint.position += new Vector3(0f, -yOffset, 0f);
				break;

			case Direction.left:
				generatorPoint.position += new Vector3(-xOffset, 0f, 0f);
				break;
		}
	}

	//Decide which Room outline will spawn so the rooms connect
	private RoomPrefab PickRoom(bool exitUp, bool exitRight, bool exitDown, bool exitLeft)
	{
		foreach (RoomPrefab rp in roomPrefabs)
		{
			if (rp.exitUp == exitUp && rp.exitRight == exitRight && rp.exitDown == exitDown && rp.exitLeft == exitLeft)
			{
				return rp;
			}
		}
		return null;
	}

	//Create the room outline
	public void CreateRoomOutline(Vector3 position, int roomNumber)
	{
		bool exitUp = Physics2D.OverlapCircle(position + new Vector3(0, yOffset), .2f, whatisRoom);
		bool exitDown = Physics2D.OverlapCircle(position + new Vector3(0, -yOffset), .2f, whatisRoom);
		bool exitRight = Physics2D.OverlapCircle(position + new Vector3(xOffset, 0), .2f, whatisRoom);
		bool exitLeft = Physics2D.OverlapCircle(position + new Vector3(-xOffset, 0), .2f, whatisRoom);

		var roomPrefab = PickRoom(exitUp, exitRight, exitDown, exitLeft);
		if (roomPrefab != null)
		{
			var room = Instantiate(roomPrefab.prefab, position, Quaternion.identity, transform);
			room.GetComponent<Room>().roomNumber = roomNumber;
			generatedOutlines.Add(room);
		}
	}
}

[System.Serializable]
public class RoomPrefab
{
	public bool exitUp;
	public bool exitRight;
	public bool exitDown;
	public bool exitLeft;
	public GameObject prefab;
} </pre>
									</div>
									</li>
									</ul>

								<ul class="actions">
									<li><a href="#Top" class="button primary">Jump to top</a></li>
								</ul>
							</div>
						</div>

						<!-- NPC and Chests -->
						<div class="wrapper style3">
							<header id="Reincarnation">
								<br>
								<div class="inner">
									<h2><u>Reincarnation mechanic and card elements</u></h2>
								</div>
							</header>
							<div class="inner">

								<video class="image left" controls src="images/Roguelike/Videos/Reincarnate.mp4"></video>

								<h3 class="major">Reincarnation
								</h3>
								<p>I made creating new objects such as Chests and NPCs, with their own Inventory, as simple as creating a child class of the "Container" Blueprint, which comes with its own Inventory Component. From there, you just give it a new static mesh, choose the name of the Container and decide how many slots the Inventory will have.</p>
								<p>Once set in the level, you can easily add the items that will start off in the Containers. You can also choose whether it will have a Quest for the Player (For NPCs), and set the Item the Player will need to donate for the Quest, and how many.</p>

								<h3 class="major">Getting stronger with cards
								</h3>
								<p>I made creating new objects such as Chests and NPCs, with their own Inventory, as simple as creating a child class of the "Container" Blueprint, which comes with its own Inventory Component. From there, you just give it a new static mesh, choose the name of the Container and decide how many slots the Inventory will have.</p>
								<p>Once set in the level, you can easily add the items that will start off in the Containers. You can also choose whether it will have a Quest for the Player (For NPCs), and set the Item the Player will need to donate for the Quest, and how many.</p>

								<ul class="actions">
									<li>
									<button class="button">See Code</button>
									<div class="codecontent">
										i = 0;
		
												while (!deck.isInOrder()) {
												  print 'Iteration ' + i;
												  deck.shuffle();
												  i++;
												}
												
												print 'It took ' + i + ' iterations to sort the deck.';
									</div>
									</li>
									</ul>

								<ul class="actions">
									<li><a href="#Top" class="button primary">Jump to top</a></li>
								</ul>
							</div>
						</div>

						<!-- Quests -->
						<div class="wrapper alt style">
							<header id="Enemies">
								<br>
								<div class="inner">
									<h2><u>Enemies</u></h2>
								</div>
							</header>
							<div class="inner">
								<video class="image left" controls src="images/Roguelike/Videos/Enemies.mp4"></video>		
								<h3 class="major">Enemy behaviour
								</h3>
								<p>Upon clicking the "Accept Quest" button on an NPC that has a Quest, all other Quests are put on hold and the Quest becomes active. The NPC asks the Player for an Item that can be placed in their Inventory. The Quest Item is a Structure variable that can be set in the Editor. </p>
								
								<ul class="actions">
									<li>
									<button class="button">See Code</button>
									<div class="codecontent">
										i = 0;
		
												while (!deck.isInOrder()) {
												  print 'Iteration ' + i;
												  deck.shuffle();
												  i++;
												}
												
												print 'It took ' + i + ' iterations to sort the deck.';
									</div>
									</li>
									</ul>

								<ul class="actions">
									<li><a href="#Top" class="button primary">Jump to top</a></li>
								</ul>
							</div>
						</div>
					</section>

				<!-- Footer -->
					<section class="wrapper style3">
						<div class="inner">
						<ul class="contact">
							<li class="icon solid fa-envelope"><a href="mailto: lewishill81@gmail.com" target="_blank">lewishill81@gmail.com</a></li>
							<li class="icon brands fa-linkedin"><a href="https://www.linkedin.com/in/lewis-hill-200425195/" target="_blank">Linkedin</a></li>
						</ul>
						</div>
					</section>

			</div>

		<!-- Scripts -->
			<script src="assets/js/jquery.min.js"></script>
			<script src="assets/js/jquery.scrollex.min.js"></script>
			<script src="assets/js/browser.min.js"></script>
			<script src="assets/js/breakpoints.min.js"></script>
			<script src="assets/js/util.js"></script>
			<script src="assets/js/main.js"></script>

	</body>
</html>